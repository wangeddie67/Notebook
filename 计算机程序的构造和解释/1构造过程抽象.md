# 第1章 构造过程抽象

*心智的活动，除了尽力产生各种简单的认识之外，主要表现在如下三个方面：1）将若干简单认识组合为一个复合认识，由此产生出各种复杂的认识。2）将两个认识放在一起对照，不管它们如何简单或者复杂，在这样做时并不将他们合而为一。由此得出有关它们的相互关系的认识。3）将有关认识与那些在实际中和它们同在的所有其他认识隔离开，这就是抽象，所有具有普遍性的认识都是这样得到的。*

---- John Locke, An essay Concerning Human Understanding.



$\triangle$ *计算过程*是存在于计算里的一类抽象事物，在其演化过程中，这些过程会去操作一些被称为*数据*的抽象事物。人们创造出一些称为*程序*的规则模式，以指导这类过程的进行。

#### 用Lisp编程

$\triangle$​ LISP，来源于LISt Processing，是一种数学记述方式。包括多种方言。

$\triangle$​ 计算过程的Lisp描述（称为*过程*）本身又可以作为Lisp的数据来表示和操作。

## 1.1 程序设计的基本元素

$\triangle$ 每一种强有力的语言都为此提供了三种机制：

- **基本表达形式**，用于表示语言所关心的最简单的个体。
- **组合的方式**，通过它们可以从较简单的东西出发构造出复合的元素。
- **抽象的方法**，通过它们可以为复合对象命名，并将他们当作单元去操作。

### 1.1.1 表达式

$\triangle$ 用键盘输入了一个*表达式*，解释器的响应就是将它对这一表达式的*求值*结果显示出来。

$\triangle$ *组合式*，用一对括号括起一些表达式，形成一个表，用于表示一个过程应用。

- 最左边是*运算符*，其他元素是*运算对象*。

$\triangle$ 将运算符放在所以运算对象左边，称为*前缀表示*。

- 优势：方便操作数扩展和嵌套。

$\triangle$ ”读入-求值-打印“循环。

### 1.1.2 命名和环境

$\triangle$​ 名字标识符称为*变量*，它的*值*也就是它所对应的那个对象。

$\triangle$ 解释器必须维护某种存储能力，以便保持有关的名字和值对偶的轨迹。这种存储称为*环境*（*全局环境*）。

### 1.1.3 组合式的求值

$\triangle$ 要求值一个组合式，做下面的事情：

- 求值该组合式的各个子表达式。
- 将作为最左子表达式（运算符）的值的那个过程应用于相应的实际参数，所谓实际参数也就是其他子表达式（运算对象）的值。

在性质上，这一求值过程是*递归*的。

$\triangle$​ 可以用一棵树的形式开表达求解过程。计算过程称为*树形积累*。

**图1.1 树形表示方法，其中显示了每个子表达式的值**

$\triangle$ 处理基础情况的方式如下规定：

- 数的值就是他们所表示的数值。
- 内部运算符的值就是能完成相应操作的机器指令序列。
- 其他名字的值就是在环境中关联于这一名字的那个对象。

**图1-1 树形表示方法，其中显示了每个子表达式的值**

$\triangle$ 定义define是一种特殊情况。

### 1.1.4 复合过程

$\triangle$ 出现在任何一种语言中的东西：

- 数和算术运算是基本的数据和过程。
- 组合式的嵌套提供了一种组织起多个操作的方法。
- 定义是一种受限的抽象手段，它为名字关联相应的值。

$\triangle$ *过程定义*。（函数）

$\triangle$ 可以用过程定义作为基本构件去定义其他过程。

### 1.1.5 过程应用的代换模型

$\triangle$ 复合过程，过程应用的计算过程是：

- 将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一个过程体求值。

上述模型称为过程应用的*代换模型*。

#### 应用序和正则序

$\triangle$ 这种“完全展开而后归约”的求值模型称为*正则序求值*；“先求值参数而后应用”的方式，称为*应用序求值*。

- 正则序求值存在重复计算的可能。
- LISP采用应用序求值。
- 超出了可以采用替换方式模拟的过程范围之后，正则序的处理变得更复杂。

### 1.1.6 条件表达式和谓词

$\triangle$ 依据遇到的不同情况，按照下面规则采取不同的工作，称为一个*分情况分析*。

$\triangle$ 首先包含一个符号，在它之后跟着一些称为*子句*的用括号括起来的表达式对偶。每个对偶中的第一个表达式是一个*谓词*，也就是说这个表示式，它的值将被解释为真或者假。

$\triangle$ *谓词*指那些返回真或假的过程，也指那种能求出真或者假的值的表达式。

$\triangle$ 复合谓词的复合运算符：AND、OR、NOT。

### 1.1.7 实例：采用牛顿法求平方根

### 1.1.8 过程作为黑箱抽象

**图1-2 sqrt程序的过程分解**

$\triangle$ *过程抽象*

#### 局部名

$\triangle$ 原则：过程的意义应不依赖于其作者为形式参数所选用的名字。

- 过程的形式参数名必须局部于有关的过程体。

$\triangle$ 形式参数的具体名字称为*约束变量*，一个过程的定义*约束*了它的所有形式参数。

$\triangle$ 如果一个变量不是被约束的，称它为*自由的*。

$\triangle$ 一个名字的定义被约束于的那一集表达式称为这个名字的作用域。

#### 内部定义和块结构

$\triangle$ *块结构*，

$\triangle$ *词法作用域*：在块结构中使用自由变量，而不需要参数传递。

## 1.2 过程及其产生的计算

**图1-3 计算6!的线性递归过程**

### 1.2.1 线性的递归和迭代

$\triangle$ *递归计算过程*：先逐步展开而后收缩。在展开阶段，构造起一个*推迟进行的操作*所形成的链条；在收缩阶段表现为这些运算的实际执行。

- 推迟执行的长度随着n值而线性增长，称为*线性递归过程*。
- 存在一些隐含的信息，由解释器维护。
- 指的是过程的进展方式，而不是语法形式。

**图1-4 计算6!的线性迭代过程**

$\triangle$ *迭代计算过程*：没有任何增长和收缩，保留计算轨迹。

- 需要n个步骤，称为*线性迭代过程*。
- 在计算过程中的任何一个点，那几个程序变量都提供了有关计算状态的完整描述。

$\triangle$ *递归过程*：这个过程的定义中（直接或间接地）引用了该过程本身。

$\triangle$ *尾递归*：总能在常量空间中执行迭代型计算过程。

### 1.2.2 树形递归

$\triangle$ *树形递归*

**图1-5 计算(fib 5)中产生的树形递归计算过程** 

#### 实例：换零钱方式的统计

### 1.2.3 增长的阶

$\triangle$ $R(n)$具有$\Theta(f(n))$的增长阶，记为$R(n)=\Theta(f(n))$（读作$f(n)$的theta），如果存在与$n$无关的整数$k_1$和$k_2$，使得：$k_1f(n)\leq R(n) \leq k_2f(n)$对于足够大的$n$都成立（对于足够大的$n$，值$R(n)$总位于$k_1f(n)$和$k_2f(n)$之间。

$\triangle$ 对于一个线性的计算过程，规模增大一倍大致将使它使用的资源增加一倍。

### 1.2.4 求幂

$\triangle$ 求幂过程的增长的阶为$\Theta(\log n)$。

### 1.2.5 最大公约数

$\triangle$ 欧几里得算法：$GCD(a,b) = GCD(b, a \mod b)$

$\triangle$ **Lame定理**：如果欧几里得算法需要用$k$步计算出一对整数的GCD，那么这对数中较小的那个数必然大于或等于第$k$个斐波那契数。

$\triangle$ 欧几里得算法的增长阶是$\Theta(\log n)$。

### 1.2.6 实例：素数检测

#### 寻找因子

$\triangle$ 利用寻找因子的算法，确定素数过程的增长阶是$\Theta(\sqrt{n})$。

#### 费马检查

$\triangle$ 基于费马小定理的算法，确定素数过程的增长阶是$\Theta(\log n)$。

$\triangle$ **费马小定理**：如果$n$是一个素数，$a$是小于$n$的任意正整数，那么$a$的$n$次方与$a$模$n$同余。

#### 概率方法

$\triangle$ *概率算法*。

