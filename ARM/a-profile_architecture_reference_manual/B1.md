# B1 AArch64应用级编程模型

本章描述AArch64应用级编程模型，包含如下章节：

- 关于应用级编程模型
- AArch64执行状态的寄存器
- 软件控制特性和EL0


## B1.1 关于应用级编程模型

本章提供应用开发需要的编程模型信息。

本章提供的信息，与在操作系统以下或更高层的系统软件中，服务和支持应用执行所需的系统信息不同。但是，系统信息的一些知识需要将应用层编程模型放到上下文中考虑。

取决于实现选择，架构支持多层执行权限，通过不同的异常等级（Exception level）来区分，EL0到EL3。EL0对应于最底的权限等级，通常描述为无特权。应用层编程模型就是执行在EL0的软件的编程模型。参见[D1](D1.md)的异常等级。

系统软件决定了异常等级，进而决定了软件运行的权限等级。当操作系统执行在EL1和EL0时，应用通常运行在无特权的EL0。这是为了：

- 允许操作系统以独占或共享的方式为应用分配系统资源。
- 为其他进程提供一定程度的保护，同时也保护操作系统，避免故障软件的破坏。

本章标注了哪里需要对于系统级的理解，以及相关的系统级描述的引用位置。

高于EL0的异常等级的执行通常被称为权限执行。

架构的系统级视角，参见[D1](D1.md)。


## B1.2 AArch64执行状态的寄存器

本章描述在EL0执行AArch64架构态时可见的寄存器和进程状态。包括如下内容：

- AArch64状态寄存器
- 进程状态，PSTATE
- 系统寄存器

### B1.2.1 AArch64架构状态寄存器

在AArch64应用层视角，Arm处理单元提供：

**R0-R30**

R0-R30。32个通用寄存器，R0到R30。每一个寄存器可以被如下访问。

- 64比特通用寄存器，称为X0到X30。
- 32比特通用寄存器，称为W0到W30。

寄存器命名映射如图B1-1。

###### 图B1-1 通用寄存器命名

X30寄存器被成为程序调用链接寄存器。

**说明** 在指令编码中，0b11111(31)用来标志零寄存器。表示操作数取指零，但是不表示ZR实现为一个物理寄存器。

**SP**

64比特专门的栈指针寄存器。栈指针的低32比特，也可以通过WSP寄存器访问。

指令中使用SP作为操作数，表示使用当前栈指针。

**说明** 在EL1，可以配置栈指针对于16字节边界。

**PC**

64比特程序计数器，保持当前指令的地址。

软件不能直接写PC。PC可以通过分支、异常入口或异常返回改写。

**说明** 试图执行非字对齐的A64指令会产生PC对齐异常，参见[D1](D1.md)。

**V0-V31**

32个SIMD和浮点寄存器，V0到V31。每一个寄存器可以被如下访问：

- 128比特寄存器，Q0到Q31。
- 64比特寄存器，D0到D31。
- 32比特寄存器，S0到S31。
- 16比特寄存器，H0到H31。
- 8比特寄存器，B0到B31。
- 128比特的元素向量。
- 64比特的元素向量。

当寄存器名字表示的比特数不能覆盖整个SIMD和浮点寄存器时，寄存器使用低位比特。如图B1-2。

###### 图B1-2 SIMD和附件寄存器命名

**FPCR, FPSR**

两个SIMD和浮点控制和状态寄存器，FPCR和FPSR。

**Z0-Z31**

32个可扩展向量寄存器，Z0到Z31，每一个寄存器可以被如下访问：

- 元素向量，向量长度*由实现决定*，范围从128到2048比特。
- 固定长度128比特元素向量，V0到V31
- 128比特寄存器，Q0到Q31。
- 64比特寄存器，D0到D31。
- 32比特寄存器，S0到S31。
- 16比特寄存器，H0到H31。
- 8比特寄存器，B0到B31。

###### 图B1-3 SVE寄存器命名

关于SVE寄存器的更多信息，参见SVE向量寄存器和SVE写入标量寄存器。

**P0-P15**

16个SVE可扩展谓词寄存器，P0到P15。参见SVE谓词寄存器。

**FFR**

SVE专门的首个失败寄存器，与谓词寄存器大小和格式相同，P0-P15。参见FFR，首个失败寄存器。

参见[D1](D1.md)。

#### AArch64架构态寄存器的伪代码描述

在伪代码中，访问寄存器的函数：

- 赋值形式用来写寄存器。
- 非赋值形式用来读寄存器。

`x[]`函数的使用：

- 读或写X0-X30，使用 `n`表示需求的寄存器。
- 读零寄存器ZR，使用 `X[31]`。

**说明** 使用伪代码 `X[31]`表示零寄存器，不表示硬件必须实现这个寄存器。

`SP[]`函数用来读写当前SP寄存器。

`PC[]`函数用来读PC寄存器。

`V[]`函数用来读写先进SIMD和浮点寄存器V0-V31，使用参数 `n`索引需要的寄存器。

`Vpart[]`函数用来读写V0-V31之一的一部分，使用参数 `n`索引需要访问的寄存器，参数 `part`表示寄存器需要的部分。参见函数描述。

`Z[]`函数用来读写SVE可扩展向量寄存器Z0-Z31，使用参数 `n`索引需要访问的寄存器。

`Z[]`，`V[]`和 `Vpart[]`函数访问相同的实际向量寄存器文件。

`X[]`，`SP[]`，`PC[]`，`V[]`，`Vpart[]`和 `Z[]`函数在[J1](J1.md)中定义。

### B1.2.2 SVE向量寄存器

SVE包含32个可扩展向量寄存器，名为Z0-Z31。

所有SVE可扩展向量寄存器具有相同的大小。

SVE可扩展向量寄存器的大小是128比特的倍数，由*实现定义*。

SVE可扩展向量寄存器最大是2048比特。

SVE可扩展向量寄存器最小是128比特。

除有声明，指令描述中，SVE指令认为SVE可扩展向量寄存器包含1个或多个大小相同的向量元素。

除有声明，指令描述中，向量元素可以被SVE指令并行处理。

当SVE可扩展向量寄存器被指令切分为向量元素时，向量元素的大小编码在指令的操作码中。向量元素的大小可以是8、16、32、64或128比特。

当SVE指令进行的向量或谓词元素操作的顺序有明显意义的会后，元素按照序号增加的顺序处理。

AArch64架构态中，SVE 256比特向量寄存器和SIMD&FP向量的布局：

###### 图B1-4 AArch64架构态中SVE向量

每一个SVE可扩展向量寄存器（Z0-Z31）的比特[127:0]，维护对应序号的AArch64架构态的SIMD&FP寄存器（V0-V31）。

在当前的异常等级，如果可访问的SVE向量长度大于128字节，任何写入V0-V31的AArch64指令，将对应SVE可扩展向量寄存器中高于比特[127]的可访问比特设置为0。

#### SVE写标量寄存器

特定的SVE指令产生一个标量结果，结果回写到AArch64结构态的通用寄存器，或者向量寄存器的元素[0]。

当SVE指令产生宽度为N比特的标量结果时，指令将结果放在目的寄存器的比特[N-1:0]。

当指令产生宽度为N比特的标量结果，而且N小于目的寄存器的最大可访问宽度RW，指令将目的寄存器的比特[RW-1:N]设置为0。

### B1.2.3 SVE谓词寄存器

SVE包含16个可扩展的谓词寄存器，名为P0-P15。

SVE谓词寄存器为向量寄存器的每一个字节维护1个比特。

SVE谓词寄存器的大小是16比特的倍数，由*实现定义*。

SVE谓词寄存器最大是256比特。

SVE谓词寄存器最小是16比特。

除有声明，指令描述中，SVE指令认为SVE可扩展向量寄存器包含1个或多个大小相同的谓词元素。

谓词寄存器可以分为一些1比特、2比特、4比特或8比特元素。

谓词寄存器中的每个谓词元素对应于一个向量元素。

当谓词寄存器被指令切分为向量元素时，谓词元素的大小编码在指令的操作码中。

如果谓词元素的最低比特是1，谓词元素的值为真。

如果谓词元素的最低比特是0，谓词元素的值为假。

对于所有SVE指令，如果下面条件都是真，除了每个谓词单元的最低比特之外的比特会被读忽略：

- 指令不用于移动谓词单元或调整谓词单元顺序。
- 指令不用于谓词逻辑操作。

对于所有SVE指令，如果下面条件都是真，除了每个谓词单元的最低比特之外的比特会被写为零：

- 指令不用于移动谓词单元或调整谓词单元顺序。
- 指令不用于谓词逻辑操作。

### B1.2.4 FFR，首个失败异常寄存器

SVE包含专用的首个失败寄存器，名为FFR。

FFR捕捉SVE首个失败或无失败向量load指令的累计失败状态。

> The FFR captures the cumulative fault status of a sequence of SVE First-fault and Non-fault vector load instructions.

FFR和谓词寄存器具有相同的大小和格式。

FFR是专用目的寄存器。

利用SETFFR指令，将在当前异常等级可访问的所有FFR比特初始化为1。

对于一个SVE首个失败或者无失败向量load中的活跃元素（Active element），禁止访问或失败的结果是将FFR中的比特被间接设置为0。

向量load指令永远不会将FFR中的比特设置为1。

在 `SETFFR`指令之后，连接一条或多条SVE首个失败或无失败load的序列之后，FFR包含一个由1或真元素，后面是0或多个假元素。

FFR中的真元素，表示包含从存储load到的有效数据的最短的连续元素序列。

可以直接读FFR的指令只有 `RDFFR`（受到谓词控制）和 `RDFFRS`。

可以直接写FFR的指令只有 `WRFFR`和 `SETFFR`。

相对于其他指令，对FFR的所有直接或间接读写都按照程序顺序发生，不需要显示同步。

> 补充：摘自[Introduction to SVE (arm.com)](https://developer.arm.com/documentation/102476/0100/SVE-architecture-fundamentals)
>
> 投机load可能对传统向量读造成挑战。如果一些元素在读的时候发生错误，那么很难回退load操作并追踪是哪一个元素发生错误。为了将投机load扩展到向量，SVE引入了首个失败向量load指令。为了允许向量访问无效页面，SVE还以内了首个失败谓词寄存器（FFR）。当利用首个失败向量load指令load SVE向量的时候，FFR寄存器根据每一个元素load成功或失败的结果进行更细。当load失败时，FFR立即注册对应的元素，并且将剩余的元素注册为0或假，而且不触发异常。一般来说，RDFFR指令用来读FFR状态。当第一个元素是假的时候，RDFFR指令结束迭代。如果第一个原始是真，RDFFR继续迭代。FFR的长度与谓词向量相同。可以用SETFFR指令初始化其值。

### B1.2.5 进程状态，PSTATE

进程状态或PSTATE是进程状态信息的抽象。所有的指令集都提供操作PSTATE元素的指令。

下面的PSTATE信息可以在EL0访问：

**条件标志**

设置标志的指令可以设置条件标准。他们是：

- **N**负条件标志。如果指令的结果被识别为补码，PE设置：
  - 如果结果是负数，设置为1。
  - 如果结构是整数或0，设置为0。
- **Z**零条件标志。设置：
  - 如果指令的结果是0，设置为1。
  - 否则，设置为0。
- **C**进位条件标志。设置：
  - 如果指令结果提供进位条件（例如加法结果发生无符号溢出），设置为1。
  - 否则，设置为0。
- **V**溢出条件标志。设置：
  - 如果指令结果发生溢出条件（例如架构结果发生有符号溢出），设置为1。
  - 否则，设置为0。

条件执行的指令检查N、Z、C和V标志，将他们与指令的条件码组合，决定指令是否必须执行。通过这种方式，指令执行是有条件的，取决于前一个操作的结果。关于条件执行的信息，参见[C6](C6.md)中*条件标准和相关指令*章节。

**异常掩码比特**

- **D**调试异常掩码标志。当EL0使能对于这个比特的修改，这个比特是可见的，而且可修改。否则，EL0从架构上忽略这个比特。
- **A**SError中断掩码标志。
- **I**IRQ中断掩码标志。
- **F**FIQ中断掩码标志。

对于每个比特，取值为：

- **0**表示异常被掩码。
- **1**表示异常没有被掩码。

> 补充：
>
> “被掩码”表示异常被屏蔽，不会被触发；“没有被掩码”表示异常没有被屏蔽，可以被触发。

对于PSTATE的系统级视角，参见[D1](D1.md)中*进程状态，PSTATE*章节。

#### 在EL0访问PSTATE域

在AArch64结构态的EL0等级，PSTATE域可以通过特殊目的寄存器访问，特殊目的寄存器可以通过MRS指令直接读，并且使用MSR（寄存器）指令直接写。表B1-1表示了访问PSTATE域的特殊目的寄存器，维护了当处理器处于AArch64架构态的EL0等级时的AArch64架构态。

###### 表B1-1 在EL0等级，使用MRS和MSR（寄存器）指令访问PSTATE域

软件也可以使用MSR（立即数）指令直接写PSTATE.{D,A,I,F}。表B1-2展示了，当PE处于AArch64架构态的EL0等级时，可以直接写PSTATE.{D,A,I,F}的MSR（立即数）指令的操作数。

###### 表B1-2 在EL0等级，使用MSR（立即数）指令访问PSTATE

然而，在AArch64架构态的EL0等级访问PSTATE.{D,A,I,F}域取决于SCTLR_EL1.UMA。

对于PSTATE域的写对于PE操作有多方面的副作用。所有这些副作用，都保证：

- 对于执行流之前的指令不可见。
- 对于执行流之后的指令可见。

#### SVE使用PSTATE的N、Z、C和V条件标志

这个小结描述SVE使用的PSTATE。

PSTATE的N、Z、C和V条件标志可以被下面的指令更新：

- SVE指令产生谓词结果，并且根据结果的值更新PSTATE的N、Z、C和V条件标志。
- SVE指令根据谓词寄存器或FFR的值更新PSTATE的N、Z、C和V条件标志：`PTEST`和 `RDFFR`（受谓词控制）。
- SVE指令根据通用寄存器的值更新PSTATE和N、Z、C和V条件标志：`CTERMEQ`和 `CTERME`。

受谓词控制的设置标志SVE指令，在设置PSTATE的N、Z、C和V条件标志时，指令的控制谓词（Governing predicate）决定哪个谓词元素是活跃的。

不受谓词控制的设置标志SVE指令，在设置PSTATE的N、Z、C和V条件标志时，所有谓词单元都是活跃的。

除了在指令描述中另有说明，SVE标志设置指令按照下面的规则更新PSTATE的N、Z、C和V条件标志：

- N；First；如果第一个活跃元素是真的，设置为1；反之清0；
- Z；None；如果任何活动元素是真的，清0；反之设置为1；
- C；Not last；如果最后一个活跃元素是真的，清0；分支设置为1；
- V；；清零。

### B1.2.6 系统寄存器

系统寄存器提供对执行条件、状态和通用系统配置的支持。系统寄存器的大部分不能在EL0访问。

但是，一些系统寄存器可以被配置为允许在EL0执行的软件访问。从EL0等级对系统寄存器的，访问权限没有执行的任何访问，使得指令行为*不确定*。可以从EL0等级访问的寄存器包括：

**缓存ID寄存器**

CTR_EL0和DCZID_EL0寄存器EL0等级缓存管理的实现参数。

**调试寄存器**

通过MDCCSR_EL0、DBGDTR_EL0、DBGDTRRX_EL0、DBGDTRTX_EL0寄存器支持调试通信通道。

**性能监视寄存器**

性能监视扩展提供计数器和配置寄存器。在EL1或更高异常等级执行的软件可以将这些寄存器配置为可以被EL0等级访问。

参见[D11](D11.md)中*性能监视扩展*。

**活跃监视寄存器**

活跃监视扩展提供计数器和配置寄存器。在EL1或更高异常等级执行的软件可以将这些寄存器配置为可以被EL0等级访问。

参见[D12](D12.md)中*活跃监视扩展*。

**线程ID寄存器**

TPIDR_EL0和TPIDRRO_EL0寄存器是两个线程ID寄存器，寄存器具有不同的访问权限。

**计时器寄存器**

下面的操作通过这些寄存器实现：

- 通过CNTFRQ_EL0读取系统计数器时钟频率。
- 通过CNTPCT_EL0和CNTVCT_EL0访问物理和虚拟的计时器计数寄存器。
- 通过CNTP_CVAL_EL0、CNTP_TVAL_EL0和CNTP_CTL_EL0访问物理的升序计数比较、降序值和计时器控制寄存器。
- 通过CNTV_CVAL_EL0、CNTV_TVAL_EL0和CNTV_CTL_EL0访问虚拟的升序计数比较、降序值和计时器控制寄存器。


## B1.3 软件控制特性和EL0

下面的小结描述了EL0视角的软件控制特性：

- 异常处理
- 等待中断和等待事件
- YIELD指令
- 应用层缓存管理
- 与调试有关的指令
- 关于PSTATE.DIT

### B1.3.1 异常处理

在Arm架构中，异常（exception）会引起程序流的改变。异常处理程序的执行从一个与发生的异常相关的向量开始，从高于EL0的异常等级开始。

异常包括：

- 中断（interrupt）。
- 内存系统中断（abort）。
- 尝试执行未定义的指令产生的异常。
- 系统调用。
- 安全监视器或超管理器陷阱（trap）。
- 调试异常。

异常处理的细节对于应用层软件不可见，在[D1](D1.md)中*AArch64架构的系统级编程模型*介绍。

`SVC`指令引起管理器调用异常。这为无特权软件提供了一种对操作系统进行系统调用的机制。

`BRK`指令产生断点指令异常。这为调试软件提供了一种在同一个PE上调试执行的机制。参见[D2](D2.md)中*断点指令异常*。

**说明** 只有A64指令集中支持 `BRK`指令。在T32和A32指令集中的等效指令是 `BKPT`。

### B1.3.2 等待中断或等待事件

`WFI`指令表示，直到WFI唤醒事件发生之前，不会有更多的指令执行。参见[D1](D1.md)中*等待中断机制*。这允许进入一个低功耗状态。

`WFE`指令表示，直到WFE唤醒事件发生之前，不会有更多的指令执行。参见[D1](D1.md)中*等待事件*。这允许进入一个低功耗状态。

### B1.3.3 YIELD指令

`YIELD`指令提供一个提示，线程进行的任务是低重要性的，所以可以让出，参见[C6](C6.md)中*YIELD*。这种机制可以用来提高同构多线程（Symmetric Multithreading, SMT）和同步多进程（Symmetric Multiprocessing, SMP）系统的整体性能。

使用 `YIELD`指令的例子，线程进入了自旋锁，或SMP系统中的snoop比特的仲裁优先级被修改。`YIELD`指令允许在SMT和SMP系统之间二进制兼容。

`YIELD`指令是 `NOP`提示指令。

`YIELD`指令在单线程系统中没有作用，但是单线程系统的开发者可以使用这条指令，表示它存在未来迁移到多处理器或多线程系统的可能。操作系统可以在需要让出提示的地方使用 `YIELD`。如果没有实现上的收益，它会被视为NOP。

### B1.3.4 应用级缓存管理

从更高的权限等级，通过SCTLR_EL1系统寄存器，可以将一小部分缓存管理指令使能在EL0等级。任何从EL0层级，对于访问权限不使能的操作的任何访问，会导致执行行为*未定义*。

关于可以使用的操作，参见[B2](B2.md)中*应用层访问与缓存相关的性能*。

### B1.3.5 调试相关指令

`BRK`指令产生断点异常。另外，在AArch64架构态和AArch32状态，`HLT`指令引起PE进入挂起执行，而且进入调试状态。这提供了使用PE外的调试器调试软件的机制，参见[H1](H1.md)的外部调试。

**说明** 在AArch32架构态，之前版本的架构定义了 `BDG`指令，为调试系统提供提示。这条指令如 `NOP`指令。Arm丢弃了 `DBG`指令。

### B1.3.6 关于PSTATE.DIT

当PSTATE.DIT是1时：

- 需要提供列在DIT下的指令；
  - 时序与寄存器提供的数据的值，以及NZCV标志的值无关。
  - 对于异步异常的响应，不随着寄存器提供的值，或NZCV标志的值改变。
- 所有的load和store的时序，必须对load或store的数值不敏感。

**说明**

- 当PSTATE.DIT置位时，load数据使用值预测，这与DIT的要求（时序与load的数据值无关）不兼容。
- Arm建议，FEAT_PAuth指令不遵循时序与指针认证（pointer authentication）使用的密钥值无关，不管PSTATE.DIT比特。
- 当PSTATE.DIT是0的时候，架构不声明任何指令的时序特性。但是，在很多落地方案中，指令的时序不随数据变化。
- 如果SVE2没有实现，FEAT_DIT控制的数据无关时序不影响SVE指令的时序特性。
- SVE或SVE2指令描述的运行信息（operational information）小节标示指令是否遵循PSTATE.DIT控制。如果SVE指令描述的运行信息（operational information）小节没有提到PSTATE.DIT或这个小节不存在，那么指令不受到PSTATE.DIT影响。
- 对于SVE和SVE2的受到谓词控制的指令，编程者需要保证，使用不影响操作的数据的值的控制谓词。

在AArch64架构态中，对应的DIT比特添加到PSTATE；在AArch32架构态中，对应的DIT比特添加到CPSR。

当异常发生，从AArch64架构态切换到AArch64架构态时，PSTATE.DIT复制到SPSR_ELx.DIT。

当异常发生，从AArch32架构态切换到AArch64架构态时，CPSR.DIT复制到SPSR_ELx.DIT。

当异常从AArch64架构态返回时：

- 当目标异常等级是AArch64结构态时，SPSR_ELx.DIT复制到PSTATE.DIT。
- 当目标异常等级是AArch32结构态时，SPSR_ELx.DIT复制到CPSR.DIT。

PSTATE.DIT可以被任何异常等级读写。

**说明**

- 

****PSTATE**.DIT can be written and read at all Exception levels.**

Note
• **PSTATE**.DIT is unchanged on entry into Debug state.
• **PSTATE**.DIT is not guaranteed to have any effect in Debug state.


## B1.4 SVE受谓词控制的指令

如果指令支持谓词，称为受谓词控制的指令。

用来为受谓词控制的指令确定活跃元素（Active elements）的谓词操作数称为控制谓词（Governing predicate）。

不具有控制谓词（Governing predicate），而且隐性将其他向量元素和谓词元素都视为活跃元素的指令，称为不受谓词控制的指令。

很多受谓词控制的指令，只使用P0-P7作为控制谓词（Governing predicate）。

当控制谓词（Governing predicate）元素是真时，其他向量或谓词操作数中对应的元素是活跃元素（Active elements）。

当控制谓词（Governing predicate）元素是假时，其他向量或谓词操作数中对应的元素是不活跃元素（Inactive elements）。

受谓词控制的指令处理活跃元素（Active elements）。

受谓词控制的指令不处理不活跃元素（Inactive elements）。

不受谓词控制的指令处理向量或谓词操作数中的所有元素。

当受谓词控制的指令写向量目的寄存器或谓词目的寄存器时，遵循下面之一：

- 目的寄存器中的不活跃元素（Inactive elements）被设置为0。
- 目的寄存器中的不活跃元素（Inactive elements）保持之前的值。

零谓词行为，目的寄存器中的不活跃元素（Inactive elements）设置为0，

合并谓词行为，目的寄存器中的不活跃元素（Inactive elements）保持之前的值。
