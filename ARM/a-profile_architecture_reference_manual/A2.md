# Chapter A2 Armv8-A Architecture Extensions

## A2.1 Armv8.0 architecture extensions

$\triangle$ The original Armv8-A architecture is called Armv8.0.

$\triangle$ **Features added to Armv8.0 in later releases**.

$\triangle$ **The Armv8.1 architectural extension**. The Armv8.1 architecture extension adds both:
- Architecture features. Some of these are mandatory, others are optional. Some features must be implemented together.
- Architectural requirements. These are mandatory.

$\triangle$ An implementation is Armv8.1 compliant if all of the following apply:
- It includes all of the Armv8.1 architectural features that are mandatory. This includes all architectural features of an optional architecture component or extension that are defined as mandatory, if the Armv8.1 compliant implementation includes the optional architecture component or extension.
- It includes all of the Armv8.1 architectural requirements.

$\triangle$ **The Armv8.2 architectural extension**. The Armv8.2 architecture extension is an extension to Armv8.1. It adds both: 
- Architectural features. Some of these are mandatory, others are optional. Some features must be implemented together.
- Architectural requirements. These are mandatory.

$\triangle$ An implementation is Armv8.2 compliant if all of the following apply:
- It is Armv8.1 compliant.
- It includes all of the Armv8.2 architectural features that are mandatory. This includes all architectural features of an optional architecture component or extension that are defined as mandatory, if the Armv8.2 compliant implementation includes the optional architecture component or extension.
- It includes all of the Armv8.2 architectural requirements.

$\triangle$ **The Armv8.3 architectural extension**. The Armv8.3 architecture extension is an extension to Armv8.2. It adds both: 
- Architectural features. Some of these are mandatory, others are optional. Some features must be implemented together.
- Architectural requirements. These are mandatory.

$\triangle$ An implementation is Armv8.3 compliant if all of the following apply:
- It is Armv8.2 compliant.
- It includes all of the Armv8.3 architectural features that are mandatory. This includes all architectural features of an optional architecture component or extension that are defined as mandatory, if the Armv8.3 compliant implementation includes the optional architecture component or extension.
- It includes all of the Armv8.3 architectural requirements.

$\triangle$ **The Armv8.4 architectural extension**. The Armv8.4 architecture extension is an extension to Armv8.3. It adds architectural features. Some of these are mandatory, others are optional. Some features must be implemented together.

$\triangle$ An implementation is Armv8.4 compliant if all of the following apply:
- It is Armv8.3 compliant.
- It includes all of the Armv8.4 architectural features that are mandatory. This includes all architectural features of an optional architecture component or extension that are defined as mandatory, if the Armv8.4 compliant implementation includes the optional architecture component or extension.

$\triangle$ **The Armv8.5 architectural extension**. The Armv8.5 architecture extension is an extension to Armv8.4. It adds architectural features. Some of these are mandatory, others are optional. Some features must be implemented together.

$\triangle$ An implementation is Armv8.5 compliant if all of the following apply:
- It is Armv8.4 compliant.
- It includes all of the Armv8.5 architectural features that are mandatory. This includes all architectural features of an optional architecture component or extension that are defined as mandatory, if the Armv8.5 compliant implementation includes the optional architecture component or extension.
- It includes all of the Armv8.5 architectural requirements.

$\triangle$ **The Armv8.6 architectural extension**. The Armv8.6 architecture extension is an extension to Armv8.5. It adds architectural features. Some of these are mandatory, others are optional. Some features must be implemented together.

$\triangle$ An implementation is Armv8.6 compliant if all of the following apply:
- It is Armv8.5 compliant.
- It includes all of the Armv8.6 architectural features that are mandatory. This includes all architectural features of an optional architecture component or extension that are defined as mandatory, if the Armv8.6 compliant implementation includes the optional architecture component or extension.
- It includes all of the Armv8.6 architectural requirements.

$\triangle$ **The Armv8.7 architectural extension**. The Armv8.7 architecture extension is an extension to Armv8.6. It adds architectural features. Some of these are mandatory, others are optional. Some features must be implemented together.

$\triangle$ An implementation is Armv8.7 compliant if all of the following apply:
- It is Armv8.6 compliant.
- It includes all of the Armv8.7 architectural features that are mandatory. This includes all architectural features of an optional architecture component or extension that are defined as mandatory, if the Armv8.7 compliant implementation includes the optional architecture component or extension.
- It includes all of the Armv8.7 architectural requirements.

$\triangle$ **The Armv8.8 architectural extension**. The Armv8.8 architecture extension is an extension to Armv8.7. It adds architectural features. Some of these are mandatory, others are optional. Some features must be implemented together.

$\triangle$ An implementation is Armv8.8 compliant if all of the following apply:
- It is Armv8.7 compliant.
- It includes all of the Armv8.8 architectural features that are mandatory. This includes all architectural features of an optional architecture component or extension that are defined as mandatory, if the Armv8.8 compliant implementation includes the optional architecture component or extension.
- It includes all of the Armv8.8 architectural requirements.

$\triangle$ **The Statistical Profiling Extension (SPE)**. SPE is an optional extension to Armv8.2. That is, SPE requires the implementation of Armv8.2.

$\triangle$ **The Scalable Vector Extension (SVE)**. SVE is an optional extension to Armv8.2. That is, SVE requires the implementation of Armv8.2.

$\triangle$ **The Activity Monitors Extension (AMU)**. AMU is an optional extension to Armv8.4. That is, AMU requires the implementation of Armv8.4.

$\triangle$ **The Memory Partitioning and Monitoring Extension (MPAM)**. MPAM is an optional extension to Armv8.2. That is, MPAM requires the implementation of Armv8.2.

### A2.1.1 Permitted implementation of subsets of Armv8.x and Armv8.(x+1) architectural features

$\triangle$ An Armv8.x compliant implementation can include any arbitrary subset of the architectural features of Armv8.(x+1), subject only to those constraints that require that certain features be implemented together.

$\triangle$ Unless this manual permits otherwise, an Armv8.x compliant implementation does not include any features of Armv8.(x+2) or later.

## A2.2 Architectural features within Armv8.0 architecture

### A2.2.1 Additional functionality added to Armv8.0 in later releases

$\triangle$ An implementation of Armv8.0 can include any or all of the features that this section describes.

$\triangle$ **FEAT_SB, Speculation Barrier**. FEAT_SB introduces a barrier to control speculation. This instruction is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.0 implementations and mandatory in Armv8.5 implementations. The following fields identify the presence of FEAT_SB: ID_AA64ISAR1_EL1.SB, ID_ISAR6_EL1.SB, ID_ISAR6.SB.

$\triangle$ **FEAT_SSBS, FEAT_SBSS2, Speculative Store Bypass Safe**. FEAT_SSBS allows software to indicate whether hardware is permitted to load or store speculatively in a manner that could give rise to a cache timing side channel, which in turn could be used to derive an address from values loaded to a register from memory. FEAT_SSBS2 provides controls for the MSR and MRS instructions to read and write the PSTATE.SSBS field. FEAT_SSBS is supported in both AArch64 and AArch32 states. FEAT_SSBS2 is supported in AArch64 state only. This feature is OPTIONAL in Armv8.0 implementations. The following fields identify the presence of FEAT_SSBS and FEAT_SSBS2: ID_AA64PFR1_EL1.SSBS, ID_PFR2_EL1.SSBS, ID_PFR2.SSBS.

$\triangle$ **FEAT_CSV2, FEAT_CSV2_2, and FEAT_CSV2_3, Cache Speculation Variant 2**. FEAT_CSV2 adds a mechanism to identify if hardware cannot disclose information about whether branch targets trained in one hardware described context can control speculative execution in a different hardware described context. FEAT_CSV2_2 adds the SCXTNUM_ELx registers, which provide a number that can be used to separate out different context numbers within their respective Exception levels for the purpose of protecting against side-channels using branch prediction and similar resources. FEAT_CSV2_3 adds a mechanism to identify if hardware cannot disclose information about whether branch targets and branch history trained in one hardware described context can control speculative execution in a different hardware described context. FEAT_CSV2 is supported in both AArch64 and AArch32 states. FEAT_CSV2_2 and FEAT_CSV2_3 are supported in AArch64 state only. FEAT_CSV2 is OPTIONAL in Armv8.0 implementations and mandatory in Armv8.5 implementations. FEAT_CSV2_2 and FEAT_CSV2_3 are OPTIONAL in Armv8.0 implementations. The following fields identify the presence of FEAT_CSV2: ID_AA64PFR0_EL1.CSV2, ID_PFR0_EL1.CSV2, ID_PFR0.CSV2. The ID_AA64PFR0_EL1.CSV2 field identifies the presence of FEAT_CSV2_2 and
FEAT_CSV2_3.

$\triangle$ **FEAT_CSV2_1p1 and FEAT_CSV2_1p2, Cache Speculation Variant 2**. For each of these features, within a hardware-described context, branch targets trained for branches situated at one address can control speculative execution of branches situated at different addresses only in a hard-to-determine way. FEAT_CSV2_1p1 does not support the SCXTNUM_ELx registers, and the contexts do not include the SCXTNUM_ELx register contexts. FEAT_CSV2_1p2 adds the SCXTNUM_ELx registers, but the contexts do not include the SCXTNUM_ELx register contexts. FEAT_CSV2_1p1 is supported in both AArch64 and AArch32 states. FEAT_CSV2_1p2 is supported in AArch64 state only. These features are OPTIONAL in Armv8.0 implementations. The following fields identify the presence of FEAT_CSV2_1p1: ID_AA64PFR1_EL1.CSV2_frac, ID_PFR0_EL1.CSV2, ID_PFR0.CSV2. The ID_AA64PFR1_EL1.CSV2_frac field identifies the presence of FEAT_CSV2_1p2.

$\triangle$ **FEAT_CSV3, Cache Speculation Variant 3**. FEAT_CSV3 adds a mechanism to identify if hardware cannot disclose information about whether data loaded under speculation with a permission or domain fault can be used to form an address, generate condition codes, or generate SVE predicate values, to be used by instructions newer than the load in the speculative sequence. This feature is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.0 implementations and mandatory in Armv8.5 implementations. This feature is mandatory when FEAT_E0PD is implemented. The following fields identify the presence of FEAT_CSV3: ID_AA64PFR0_EL1.CSV3, ID_PFR2_EL1.CSV3, ID_PFR2.CSV3.

$\triangle$ **FEAT_SPECRES, Speculation restriction instructions**. FEAT_SPECRES adds the CFP RCTX, CPP RCTX, DVP RCTX, CFPRCTX, CPPRCTX, and DVPRCTX System instructions. These instructions prevent predictions based on information gathered from earlier execution within a particular execution context from affecting the later speculative execution within that context, to the extent that the speculative execution is observable through side channels. This feature is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.0 implementations and mandatory in Armv8.5 implementations. The following fields identify the presence of FEAT_SPECRES: ID_AA64ISAR1_EL1.SPECRES, ID_ISAR6_EL1.SPECRES, ID_ISAR6.SPECRES.

$\triangle$ **FEAT_CP15SDISABLE2, CP15SDISABLE2**. FEAT_CP15SDISABLE2 provides an implementation-defined mechanism, the CP15SDISABLE2 signal, which when asserted HIGH prevents writes to a set of Secure CP15 registers. This signal is analogous to the existing CP15SDISABLE signal. This feature is supported only when EL3 is executing in AArch32 state. This feature is OPTIONAL in Armv8.0 implementations.

$\triangle$ **FEAT_DoubleLock, Double Lock**. FEAT_DoubleLock is the mnemonic used for the OS Double Lock. If FEAT_DoPD is not implemented and FEAT_Debugv8p2 is implemented, this feature is OPTIONAL. If FEAT_DoPD is not implemented and FEAT_Debugv8p2 is not implemented, this feature is mandatory. If FEAT_DoPD is implemented, this feature is not implemented. The ID_AA64DFR0_EL1.DoubleLock field identifies that the OS Double Lock has been implemented.

$\triangle$ **FEAT_DGH, Data Gathering Hint**. FEAT_DGH adds the Data Gathering Hint instruction to the hint space. This instruction is added to the A64 instruction set only. This feature is OPTIONAL in Armv8.0 implementations. The ID_AA64ISAR1_EL1.DGH field identifies the presence of FEAT_DGH.

$\triangle$ **FEAT_ETS, Enhanced Translation Synchronization**. FEAT_ETS adds support for enhanced memory access ordering requirements for translation table walks. This feature is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.0 implementations and mandatory in Armv8.7 implementations. The following fields identify the presence of FEAT_ETS: ID_AA64MMFR1_EL1.ETS, ID_MMFR5_EL1.ETS, ID_MMFR5.ETS.

$\triangle$ **FEAT_nTLBPA, Intermediate caching of translation table walks**. FEAT_nTLBPA adds a mechanism to identify if the intermediate caching of translation table walks does not include non-coherent caches of previous valid translation table entries since the last completed TLBI applicable to the PE. This feature is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.0 implementations. The following fields identify the presence of FEAT_nTLBPA: ID_AA64MMFR1_EL1.nTLBPA, ID_MMFR5_EL1.nTLBPA, ID_MMFR5.nTLBPA.

$\triangle$ **FEAT_PCSRv8, PC Sample-based Profiling Extension**. FEAT_PCSRv8 adds support for PC Sample-based Profiling Extension that provides coarse-grained, non-invasive profiling by an external debugger. This feature is OPTIONAL in Armv8.0 implementations. The following fields identify the presence of FEAT_PCSRv8: EDDEVID.PCSample, DBGDEVID.PCSample, EDDEVID1.PCSROffset, DBGDEVID1.PCSROffset, PMDEVID.PCSample.

### A2.2.2 Architectural requirements within Armv8.0 architecture

$\triangle$ The Armv8.0 architecture includes some mandatory changes, that have been added to the architecture at a later date, that are not associated with a feature.

$\triangle$ **Prefetch speculation protection**. When substituting a direct branch with another direct branch, or a `NOP` with a direct branch, by the modified PE, at around the time that the executing PE is executing the software being modified, prefetch speculation protection prevents the old instructions from accidentally being fetched to the executing PE.

$\triangle$ An implementation of the Armv8.0 architecture must comply with all of the additional requirements. When combined with the mandatory architectural features that have been added to the Armv8.0 architecture, such an implementation is also called an implementation of the Armv8.0 architecture.

## A2.3 The Armv8 Cryptographic Extension

$\triangle$ The Armv8.0 Cryptographic Extension provides instructions for the acceleration of encryption and decryption, and includes the following features:
- FEAT_AES, which includes the `AESD` and `AESE` instructions.
- FEAT_PMULL, which includes the `PMULL`, `PMULL2` instructions.
- FEAT_SHA1, which includes the `SHA1*` instructions.
- FEAT_SHA256, which includes the `SHA256*` instructions.

$\triangle$ From Armv8.2, an implementation of the Armv8.0 Cryptographic Extension can include either or both of:
- The AES functionality, including support for multiplication of 64-bit polynomials. The ID_AA64ISAR0_EL1.AES field indicates whether this functionality is supported.
- The SHA1 and SHA2-256 functionality. The ID_AA64ISAR0_EL1.{SHA2, SHA1} fields indicate whether this functionality is supported.

$\triangle$ The presence of the Cryptographic Extension in an implementation is subject to export license controls. The Cryptographic Extension is an extension of the SIMD support and operates on the vector register file.

$\triangle$ The Cryptographic Extension also provides multiply instructions that operate on long polynomials.

$\triangle$ The Cryptographic Extension provides this functionality in AArch64 state and AArch32 state, and an implementation that supports both AArch64 state and AArch32 state provides the same Cryptographic Extension functionality in both states.

### A2.3.1 Armv8.2 extensions to the Cryptographic Extension

$\triangle$ **FEAT_SHA512, Advanced SIMD SHA512 instructions**. FEAT_SHA512 adds Advanced SIMD instructions that support SHA2-512 functionality. These instructions are added to the A64 instruction set only. Implementation of FEAT_SHA512 requires implementation of the Armv8.0 Cryptographic Extension FEAT_SHA1 and FEAT_SHA256 functionality. The ID_AA64ISAR0_EL1.SHA2 field identifies the presence of FEAT_SHA512.

$\triangle$ **FEAT_SHA3, Advanced SIMD SHA3 instructions**. FEAT_SHA3 adds Advanced SIMD instructions that support SHA3 functionality. These instructions are added to the A64 instruction set only. Implementation of FEAT_SHA3 requires implementation of the Armv8.0 Cryptographic Extension FEAT_SHA1 and FEAT_SHA256 functionality. The ID_AA64ISAR0_EL1.SHA3 field identifies the presence of FEAT_SHA3.

$\triangle$ **FEAT_SM3, Advanced SIMD SM3 instructions**. FEAT_SM3 adds Advanced SIMD instructions that support the Chinese cryptography  algorithm SM3. These instructions are added to the A64 instruction set only. Implementation of FEAT_SM3 is independent of the implementation of any SHA functionality. The ID_AA64ISAR0_EL1.SM3 field identifies the presence of FEAT_SM3.

$\triangle$ **FEAT_SM4, Advanced SIMD SM4 instructions**. FEAT_SM4 adds Advanced SIMD instructions that support the Chinese cryptography algorithm SM4. Implementation of FEAT_SM4 is independent of the implementation of any SHA functionality. These instructions are added to the A64 instruction set only. The ID_AA64ISAR0_EL1.SM4 field identifies the presence of FEAT_SM4.

## A2.4 The Armv8.1 architecture extension

### A2.4.1 Architectural features added by Armv8.1

$\triangle$ An implementation of the Armv8.1 extension must include all of the features that this section describes as mandatory. Such an implementation, when combined with the additional requirements of Armv8.1, is also called an implementation of the Armv8.1 architecture.

$\triangle$ **FEAT_LSE, Large System Extensions**. FEAT_LSE introduces a set of atomic instructions:
- Compare and Swap instructions, `CAS` and `CASP`.
- Atomic memory operation instructions, `LD<OP>` and `ST<OP>`, where `<OP>` is one of `ADD`, `CLR`, `EOR`, `SET`, `SMAX`, `SMIN`, `UMAX`, and `UMIN`.
- Swap instruction, `SWP`.

These instructions are added only to the A64 instruction set. This feature is mandatory in Armv8.1 implementations. Implementations of FEAT_VHE require the implementation of FEAT_LSE. The ID_AA64ISAR0_EL1.Atomic field identifies the presence of FEAT_LSE.

$\triangle$ **FEAT_RDM, Advanced SIMD rounding double multiply accumulate instructions**. FEAT_RDM introduces Rounding Double Multiply Add/Subtract Advanced SIMD instructions. This feature is mandatory in Armv8.1 implementations. The following fields identify the presence of FEAT_RDM: ID_AA64ISAR0_EL1.RDM, ID_ISAR5_EL1.RDM, ID_ISAR5.RDM.

$\triangle$ **FEAT_LOR, Limited ordering regions**. Limited ordering regions allow large systems to perform special Load-Acquire and Store-Release instructions that provide order between the memory accesses to a region of the PA map as observed by a limited set of observers. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.1 implementations. The ID_AA64MMFR1_EL1.LO field identifies the presence of FEAT_LOR.

$\triangle$ **FEAT_HPDS, Hierarchical permission disables**. FEAT_HPDS introduces the facility to disable the hierarchical attributes, APTable, PXNTable, and UXNTable, in the translation tables. This disable has no effect on the NSTable bit. This feature is mandatory in Armv8.1 implementations. This feature is added only to the VMSAv8-64 translation regimes. Armv8.2 extends this to the AArch32 translation regimes, see FEAT_AA32HPD. The ID_AA64MMFR1_EL1.HPDS field identifies the presence of FEAT_HPDS.

$\triangle$ **FEAT_HAFDBS, Hardware management of the Access flag and dirty state**. In Armv8.0, all updates to the translation tables are performed by software. From Armv8.1, for the VMSAv8-64 translation regimes only, hardware can perform updates to the translation tables in two contexts:
- Hardware management of the Access flag.
- Hardware management of dirty state, with updates to a dirty state in the translation tables.

The dirty state is introduced in Armv8.1. Hardware management of dirty state can be enabled only when hardware management of the Access flag is also enabled. This feature is OPTIONAL in Armv8.1 implementations. It is IMPLEMENTATION DEFINED whether this is implemented. The ID_AA64MMFR1_EL1.HAFDBS field identifies the presence of FEAT_HAFDBS.

$\triangle$ **FEAT_PAN, Privileged access never**. FEAT_PAN adds a bit to PSTATE. When the value of this PAN state bit is 1, any privileged data access from EL1, or EL2 when HCR_EL2.E2H is 1, to a virtual memory address that is accessible to data accesses at EL0, generates a Permission fault. This feature is mandatory in Armv8.1 implementations. This feature is supported in both AArch64 and AArch32 states. The following fields identify the presence of FEAT_PAN: ID_AA64MMFR1_EL1.PAN, ID_MMFR3_EL1.PAN, ID_MMFR3.PAN.

$\triangle$ **FEAT_VMID16, 16-bit VMID**. In an Armv8.1 implementation, when EL2 is using AArch64, the virtual machine identifier (VMID) size is an IMPLEMENTATION DEFINED choice of 8 bits or 16 bits. This feature is OPTIONAL in Armv8.1 implementations. When implemented, this feature is supported only when EL2 is using AArch64. The ID_AA64MMFR1_EL1.VMIDBits field identifies the supported VMID size.

$\triangle$ **FEAT_VHE, Virtualization Host Extensions**. Armv8.1 introduces the Virtualization Host Extensions (VHE) that provide enhanced support for Type 2 hypervisors in Non-secure state. This feature is mandatory in Armv8.1 implementations. An implementation that includes FEAT_VHE requires FEAT_LSE to be implemented. The ID_AA64MMFR1_EL1.VH field identifies the presence of FEAT_VHE. The following fields indicate the presence of the Virtualization Host Extensions for debug, including the changes for the PC Sample-based Profiling Extension and the Performance Monitors Extension: ID_AA64DFR0_EL1.DebugVer. ID_DFR0_EL1.{CopSDbg, CopDbg}.

$\triangle$ **FEAT_PMUv3p1, PMU Extensions v3.1**. Armv8.1 makes the following enhancements to the Performance Monitors Extension:
- The event number space is extended to 16 bits to allow additional IMPLEMENTATION DEFINED event types, and the reserved space for future additions to the architecturally-defined event types is extended.
- The HPMD bit is added to MDCR_EL2. This bit disables event counting at EL2.
- The STALL_FRONTEND and STALL_BACKEND events are required to be implemented.

The Performance Monitors Extension is an OPTIONAL feature, but if it is implemented, an Arm8.1 implementation must include FEAT_PMUv3p1. The following fields identify the presence of FEAT_PMUv3p1: ID_AA64DFR0_EL1.PMUVer, ID_DFR0_EL1.PerfMon, ID_DFR0.PerfMon.

### A2.4.2 Additional requirements of Armv8.1

$\triangle$ **FEAT_CRC32, Changes to CRC32 instructions**. All implementations of the Armv8.1 architecture are required to implement the `CRC32*` instructions. These are OPTIONAL in Armv8.0. The following fields identify the presence of the CRC32* instructions: ID_AA64ISAR0_EL1.CRC32, ID_ISAR5_EL1.CRC32, ID_ISAR5.CRC32.

$\triangle$ An implementation of the Armv8.1 extension must comply with all of the additional requirements. Such an implementation, when combined with the mandatory architectural features of Armv8.1, is also called an implementation of the Armv8.1 architecture.

### A2.4.3 Features added to the Armv8.1 extension in later releases

$\triangle$ **FEAT_PAN3, Support for SCTLR_ELx.EPAN**. FEAT_PAN3 adds a bit to SCTLR_EL1 and SCTLR_EL2, EPAN, to support using Privileged Access Never with instruction accesses for stage 1 translation regimes. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.1 implementations and mandatory in Armv8.7 implementations. The ID_AA64MMFR1_EL1.PAN field identifies the presence of FEAT_PAN3.

### A2.4.4 Features made OPTIONAL in Armv8.1 implementations

$\triangle$ The feature that has been made OPTIONAL in Armv8.1 implementations is FEAT_PAN2.

## A2.5 The Armv8.2 architecture extension

### A2.5.1 Architectural features added by Armv8.2
$\triangle$ An implementation of the Armv8.2 extension must include all of the features that this section describes as mandatory. Such an implementation, when combined with the additional requirements of Armv8.2, is also called an implementation of the Armv8.2 architecture.

$\triangle$ **FEAT_ASMv8p2, Armv8.2 changes to the A64 ISA**. FEAT_ASMv8p2 adds the `BFC` instruction to the A64 instruction set as an alias of `BFM`. It also requires that the `BFC` instruction and the A64 pseudo-instruction `REV64` are implemented by assemblers. This change to the instruction set and assembler requirements is mandatory in an Armv8.2 implementation.

$\triangle$
- In Armv8.0 and Armv8.1, the A64 pseudo-instruction `REV64` is OPTIONAL.
- Because this feature relates to support for an instruction alias and for a pseudo-instruction, there are no corresponding feature ID register fields.
 
$\triangle$ **FEAT_PAN2, `AT S1E1R` and `AT S1E1W` instruction variants affected by PSTATE.PAN**. FEAT_PAN2 adds variants of the AArch64 AT S1E1R and AT S1E1W instructions and the AArch32 ATS1CPR and ATS1CPW instructions. These instructions factor in the PSTATE.PAN bit when determining whether or not the location will generate a Permission fault for a privileged access, as is reported in the PAR. This feature is OPTIONAL in Armv8.1 implementations and mandatory in Armv8.2 implementations. These instructions are added to the A64 and A32/T32 instruction sets. The following fields identify the presence of FEAT_PAN2: ID_AA64MMFR1_EL1.PAN, ID_MMFR3_EL1.PAN, ID_MMFR3.PAN.

$\triangle$ **FEAT_FP16, Half-precision floating-point data processing**.
FEAT_FP16 supports:
- Half-precision data-processing instructions for Advanced SIMD and floating-point in both AArch64 and AArch32 states.
- The FPCR.FZ16 and FPSCR.FZ16 bits, which enables flushing of denormalized numbers to zero for half-precision data-processing instructions.

This feature is OPTIONAL in Armv8.2 implementations, unless one of the following is implemented:
- The Scalable Vector Extension (SVE).
- FEAT_FHM.
  
If SVE or FEAT_FHM is implemented, FEAT_FP16 is implemented. From Armv8.4, if FEAT_FHM is not implemented, FEAT_FP16 is not implemented. When this feature is implemented it is implemented in both Advanced SIMD and floating-point, and in AArch64 and AArch32 states. The following fields identify the presence of FEAT_FP16: ID_AA64PFR0_EL1.{FP, AdvSIMD}, MVFR1_EL1.{FPHP, SIMDHP}, MVFR1.{FPHP, SIMDHP}.

$\triangle$ **FEAT_DotProd, Advanced SIMD dot product instructions**. FEAT_DotProd provides instructions to perform the dot product of two 32-bit vectors, accumulating the result in a third 32-bit vector. This can be performed using signed or unsigned arithmetic. This feature is OPTIONAL in Armv8.2 implementations and mandatory in Armv8.4 implementations. These instructions are added to the A64 and A32/T32 instruction sets. The following fields identify the presence of FEAT_DotProd: ID_AA64ISAR0_EL1.DP, ID_ISAR6_EL1.DP, ID_ISAR6.DP.

$\triangle$ **FEAT_FHM, Floating-point half-precision multiplication instructions**. FEAT_FHM adds floating-point multiplication instructions. These instructions are added to the A64 and A32/T32 instruction sets. This feature is OPTIONAL in Armv8.2 implementations, and can be implemented only when FEAT_FP16 is implemented. This feature is mandatory in Armv8.4 implementations when FEAT_FP16 is implemented. This feature is not implemented in Armv8.4 implementations when FEAT_FP16 is not implemented. The following fields identify the presence of FEAT_FHM: ID_AA64ISAR0_EL1.FHM, ID_ISAR6_EL1.FHM, ID_ISAR6.FHM.

$\triangle$ **FEAT_LSMAOC, AArch32 Load/Store Multiple instruction atomicity and ordering controls**. FEAT_LSMAOC adds controls that disable legacy behavior of AArch32 load multiple and store multiple instructions, and provide a trap of one aspect of this legacy behavior. Implementation of FEAT_LSMAOC is OPTIONAL. When implemented it provides:
- LSMAOE fields in the SCTLR_EL1, SCTLR_EL2, HSCTLR, and SCTLR registers. These fields can have the following effects on the behavior of AArch32 load multiple and store multiple instructions:
    - An interrupt can be taken between two memory accesses made by a single load multiple or store multiple instruction.
    - The memory accesses made by a single load multiple or store multiple instruction to Device memory with the non-Reordering attribute can be reordered.
- nTLSMD fields in the SCTLR_EL1, SCTLR_EL2, HSCTLR, and SCTLR registers. These fields can cause an access to Device-nGRE, Device-nGnRE, or Device-nGnRnE memory by an AArch32 load multiple and store multiple instruction to generate an Alignment fault. The following fields identify the presence of FEAT_LSMAOC: ID_AA64MMFR2_EL1.LSM, ID_MMFR4_EL1.LSM, ID_MMFR4.LSM.

$\triangle$ Armv8.2 deprecates software dependence on the legacy behavior of AArch32 load multiple and store multiple instructions, and these fields disable this behavior.

$\triangle$ **FEAT_UAO, Unprivileged Access Override control**. Armv8.2 adds a bit to PSTATE. When the value of PSTATE.UAO is 1, and when executed at EL1 or at EL2 with HCR_EL2.{E2H, TGE} == {1, 1}, the memory accesses made by the load/store unprivileged instructions behave as if they were made by the load/store register instructions. See Load/store unprivileged on page C3-260 and Load/store register on page C3-256. This feature is mandatory in Armv8.2 implementations. This feature is supported in AArch64 state only. The ID_AA64MMFR2_EL1.UAO field identifies the presence of FEAT_UAO.

$\triangle$ **FEAT_DPB, DC CVAP instruction**. FEAT_DPB introduces a mechanism to identify and manage persistent memory locations in a shared memory hierarchy, including adding the `DC CVAP` instruction. This feature is mandatory in Armv8.2 implementations. This feature is supported in AArch64 state only. The ID_AA64ISAR1_EL1.DPB field identifies the presence of FEAT_DPB. 

$\triangle$ **FEAT_VPIPT, VMID-aware PIPT instruction cache**. FEAT_VPIPT supports a instruction cache type, described as the VMID-aware PIPT (VPIPT) instruction cache. This feature is supported in both AArch64 and AArch32 states. The CTR_EL0.L1Ip and CTR.L1Ip fields identify the presence of FEAT_VPIPT.

$\triangle$ Armv8.2 adds VPIPT to the set of supported cache types, meaning an Armv8.2 implementation is permitted to implement VPIPT caches, but is not required to do so.

$\triangle$ **FEAT_AA32HPD, AArch32 hierarchical permission disables**. FEAT_HPDS introduced the ability to disable the hierarchical attributes, APTable, PXNTable, and UXNTable, in the VMSAv8-64 translation regimes. FEAT_AA32HPD extends this functionality to the VMSAv8-32 translation regimes when those regimes are using the Long descriptor Translation Table format. This feature is OPTIONAL in Armv8.2 implementations. It is IMPLEMENTATION DEFINED whether this is implemented. The ID_MMFR4_EL1.HPDS and ID_MMFR4.HPDS fields identify the presence of FEAT_AA32HPD.

$\triangle$ **FEAT_HPDS2, Translation table page-based hardware attributes**. Armv8.2 provides a mechanism to allow operating systems or hypervisors to make up to four bits of Translation Table final-level descriptors available for IMPLEMENTATION DEFINED hardware use. This functionality is available for all translation regimes in AArch64 state and for stages of translation in AArch32 state that use the Long descriptor Translation Table format. FEAT_HPDS2 is OPTIONAL in Armv8.2 implementations, but implementation of FEAT_HPDS2 requires implementation of both:
- FEAT_HPDS.
- FEAT_AA32HPD, if any Exception level higher than EL0 can use AArch32.

The following fields identify the presence of FEAT_HPDS2: ID_AA64MMFR1_EL1.HPDS, ID_MMFR4_EL1.HPDS, ID_MMFR4.HPDS.

$\triangle$ For stage 1 translations, page-based hardware attributes can be used only for a stage of translation for which the Hierarchical permission disables field has a value of 1.

$\triangle$ **FEAT_LPA, Large PA and IPA support**. FEAT_LPA:
- Allows a larger intermediate physical address (IPA) and PA space of up to 52 bits when using the 64KB translation granule.
- Allows a level 1 block size where the block covers a 4TB address range for the 64KB translation granule if the implementation support 52 bits of PA.

This is an OPTIONAL feature in Armv8.2 implementations. It is IMPLEMENTATION DEFINED whether it is implemented. This feature is supported in AArch64 state only. The ID_AA64MMFR0_EL1.PARange field identifies the presence of FEAT_LPA.

$\triangle$ **FEAT_LVA, Large VA support**. FEAT_LVA supports a larger VA space for each translation table base register of up to 52 bits when using the 64KB translation granule. This feature is supported in AArch64 state only. This is an OPTIONAL feature in Armv8.2 implementations. It is IMPLEMENTATION DEFINED whether it is implemented. If FEAT_LVA is implemented, then any implemented trace macrocell must be at least ETMv4.2 for Armv8-A, and FEAT_ETE for Armv9-A. The ID_AA64MMFR2_EL1.VARange field identifies the presence of FEAT_LVA.

$\triangle$ **FEAT_TTCNP, Translation table Common not private translations**. FEAT_TTCNP permits multiple PEs in the same Inner Shareable domain to use the same translation tables for a given stage of address translation. This feature is mandatory in Armv8.2 implementations. This facility is available for all VMSAv8-64 translation regimes and for VMSAv8-32 translation stages that use the Long descriptor Translation Table format. The following fields identify the presence of FEAT_TTCNP: ID_AA64MMFR2_EL1.CnP, ID_MMFR4_EL1.CnP, ID_MMFR4.CnP.

$\triangle$ **FEAT_XNX, Translation table stage 2 Unprivileged Execute-never**. FEAT_XNX extends the stage 2 translation table access permissions to provide control of whether memory is executable at EL0 independent of whether it is executable at EL1. This feature is mandatory in Armv8.2 implementations that implement EL2. This facility is available for stage 2 translation stages in VMSAv8-64 and VMSAv8-32. The following fields identify the presence of FEAT_XNX: ID_AA64MMFR1_EL1.XNX, ID_MMFR4_EL1.XNX, ID_MMFR4.XNX.

$\triangle$ **FEAT_Debugv8p2, Debug v8.2**. FEAT_Debugv8p2 covers a selection of mandatory changes, including:
- If the Core power domain is powered up and DoubleLockStatus() == TRUE, EDPRSR.{DLK,SPD,PU} is only permitted to read {UNKNOWN, 0, 0}.
- The definition of Exception Catch debug events is extended to include reset entry.
- All CONSTRAINED UNPREDICTABLE cases that generate Exception Catch debug events are removed.
- Controls are added to EDECCR to control Exception Catch debug event generation on exception return.
- All IMPLEMENTATION DEFINED control of external debug accesses to OSLAR_EL1 is removed.
- `ExternalSecureNoninvasiveDebugEnabled()` cannot override software controls of counting attributable events in Secure state.

If FEAT_Debugv8p2 is implemented, FEAT_DoubleLock is OPTIONAL. The fields that identify the presence of FEAT_Debugv8p2 are: ID_AA64DFR0_EL1.DebugVer and DBGDIDR.Version, ID_DFR0_EL1.{CopSDbg, CopDbg} and ID_DFR0.{CopSDbg, CopDbg}, EDDEVARCH.ARCHID.

$\triangle$ **FEAT_PCSRv8p2, PC Sample-based profiling**. In Armv8.2, the control and implementation of the OPTIONAL PC Sample-based Profiling extension is moved from ED\*SR Debug registers to PM\*SR registers in the Performance Monitors address space. The PC Sample-based Profiling Extension is an OPTIONAL feature. If it is implemented, an Arm8.2 implementation must also include FEAT_PCSRv8p2. If Secure EL2 and PC Sample-based Profiling are both implemented, FEAT_PCSRv8p2 is mandatory. The following fields identify the presence of FEAT_PCSRv8p2: EDDEVID.PCSample, DBGDEVID.PCSample, EDDEVID1.PCSROffset, DBGDEVID1.PCSROffset, PMDEVID.PCSample.

$\triangle$ **FEAT_IESB, Implicit Error Synchronization event**. FEAT_IESB adds an implicit error synchronization event at exception entry and return, controlled by the added SCTLR_ELx.IESB fields. An IESB field is added to the ESR_ELx syndrome registers. The implicit error synchronization events affect the same synchronizable asynchronous events that are synchronized by the ESB instruction. This feature is OPTIONAL in Armv8.2 implementations. This feature is supported in AArch64 state only. The ID_AA64MMFR2_EL1.IESB field identifies the presence of FEAT_IESB.

$\triangle$ **FEAT_F32MM, Single-precision Matrix Multiplication**. FEAT_F32MM adds support for the SVE FP32 single-precision floating-point matrix multiplication variant of the `FMMLA` instruction. This feature is OPTIONAL in Armv8.2 implementations. This feature is supported in AArch64 state only. FEAT_F32MM requires FEAT_SVE. The ID_AA64ZFR0_EL1.F32MM field identifies the presence of FEAT_F32MM.

$\triangle$ **FEAT_F64MM, Single-precision Matrix Multiplication**. FEAT_F64MM adds support for the following SVE instructions: `FMMLA (FP64 double-precision variant)`, `LD1ROB (scalar plus immediate)`, `LD1ROB (scalar plus scalar)`, `LD1ROD (scalar plus immediate)`, `LD1ROD (scalar plus scalar)`, `LD1ROH (scalar plus immediate)`, `LD1ROH (scalar plus scalar)`, `LD1ROW (scalar plus immediate)`, `LD1ROW (scalar plus scalar)`, `TRN1`, `TRN2 (vectors)` (128-bit variant), `UZP1`, `UZP2 (vectors)` (128-bit variant), `ZIP1`, `ZIP2 (vectors)` (128-bit variant). This feature is OPTIONAL in Armv8.2 implementations. This feature is supported in AArch64 state only. FEAT_F64MM requires FEAT_SVE. The ID_AA64ZFR0_EL1.F64MM field identifies the presence of FEAT_F64MM.

$\triangle$ **Extensions to the Arm Cryptographic Extensions**. See FEAT_SHA512 and FEAT_SM3.

### A2.5.2 Additional requirements of Armv8.2

$\triangle$ **Change to ACTLR2 and HCTLR2 registers**. In AArch32 state, the ACTLR2 and HACTLR2 registers become mandatory.

$\triangle$ **Implementation of RAS Extension**. The RAS Extension must be implemented, 

$\triangle$ An implementation of the Armv8.2 extension must comply with all of the additional requirements. Such an implementation, when combined with the mandatory architectural features of Armv8.2, is also called an implementation of the Armv8.2 architecture.

$\triangle$ If FEAT_PMUv3 is implemented, the feature FEAT_PMUv3p4 is OPTIONAL in Armv8.2 implementations.

### A2.5.3 Features added to the Armv8.2 extension in later releases

$\triangle$ **FEAT_EVT, Enhanced Virtualization Traps**. FEAT_EVT introduces additional traps for EL1 and EL0 Cache controls. These traps are independent of existing controls. This feature is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.2 implementations and is mandatory in Armv8.5. ID_AA64MMFR2_EL1.EVT identifies the presence of the AArch64 traps controls. ID_MMFR4_EL1.EVT and ID_MMFR4.EVT identify the presence of the AArch32 traps.

$\triangle$ **FEAT_DPB2, DC CVADP instruction**. FEAT_DPB2 allows two levels of cache clean to the Point of Persistence by:
- Redefining Point of Persistence, which changes the scope of DC CVAP.
- Defining a Point of Deep Persistence.
- Adding the DC CVADP System instruction.

This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.2 implementations and is mandatory in Armv8.5 implementations. The ID_AA64ISAR1_EL1.DPB field identifies the presence of FEAT_DPB2.

$\triangle$ **FEAT_BF16, AArch64 BFloat16 instructions**. FEAT_BF16 supports the BFloat16, or BF16, 16-bit floating-point storage format in AArch64 state. This format supports:
- The BFloat16 floating-point data type.
- Arithmetic instructions to accelerate dot products and matrix multiplications of BF16 values.
- Instructions to convert single-precision floating-point values to BF16 format.
- Arithmetic instructions to multiply BFloat16 values and accumulate into single-precision results.

This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.2 implementations and mandatory in Armv8.6 implementations. The ID_AA64ISAR1_EL1.BF16 field identifies the presence of FEAT_BF16. When both Advanced SIMD and SVE are implemented, the ID_AA64ISAR1_EL1.BF16 and ID_AA64ZFR0_EL1.BF16 fields must return the same value.

$\triangle$ **FEAT_AA32BF16, AArch32 BFloat16 instructions**. FEAT_AA32BF16 supports the BFloat16, or BF16, 16-bit floating-point storage format in AArch32 state. This format supports:
- The BFloat16 floating-point data type.
- Arithmetic instructions to accelerate dot products and matrix multiplications of BF16 values.
- Instructions to convert single-precision floating-point values to BF16 format.

This feature is supported in AArch32 state only. This feature is OPTIONAL in Armv8.2 implementations. The ID_ISAR6_EL1.BF16 and ID_ISAR6.BF16 fields identify the presence of FEAT_AA32BF16.

$\triangle$ **FEAT_I8MM, AArch64 Int8 matrix multiplication instructions**. FEAT_I8MM introduces integer matrix multiply-accumulate instructions and mixed sign dot product instructions. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.2 implementations and mandatory in Armv8.6 implementations. The ID_AA64ISAR1_EL1.I8MM field identifies the presence of FEAT_I8MM. When both Advanced SIMD and SVE are implemented, the ID_AA64ISAR1_EL1.I8MM and the ID_AA64ZFR0_EL1.I8MM fields must return the same value.

$\triangle$ **FEAT_AA32I8MM, AArch32 Int8 matrix multiplication instructions**. FEAT_AA32I8MM introduces integer matrix multiply-accumulate instructions and mixed sign dot product instructions. This feature is supported in AArch32 state only. This feature is OPTIONAL in Armv8.2 implementations. The ID_ISAR6_EL1.I8MM and ID_ISAR6.I8MM fields identify the presence of FEAT_AA32I8MM.

### A2.5.4 Features made OPTIONAL in Armv8.2 implementations

$\triangle$ The features that have been made OPTIONAL in Armv8.2 implementations are: FEAT_FlagM, FEAT_LSE2, FEAT_LRCPC2.

## A2.6 The Armv8.3 architecture extension

### A2.6.1 Architectural features added by Armv8.3

$\triangle$ An implementation of the Armv8.3 extension must include all of the features that this section describes as mandatory. Such an implementation is also called an implementation of the Armv8.3 architecture. 

$\triangle$ **FEAT_FCMA, Floating-point complex number instructions**. FEAT_FCMA introduces instructions for floating-point multiplication and addition of complex numbers. These instructions are added to the A64 and A32/T32 instruction sets. This feature is mandatory in Armv8.3 implementations. The half-precision versions of these instructions are implemented only if FEAT_FP16 is implemented. Otherwise they are UNDEFINED. The fields that identify the presence of FEAT_FCMA are:  ID_AA64ISAR1_EL1.FCMA, ID_ISAR5_EL1.VCMA, ID_ISAR5.VCMA.

$\triangle$ **FEAT_JSCVT, JavaScript conversion instructions**. FEAT_JSCVT introduces instructions that perform a conversion from a double-precision floating point value to a signed 32-bit integer, with rounding to zero. These instructions are added to the A64 and A32/T32 instruction sets. This feature is mandatory in Armv8.3 implementations. The fields that identify the presence of FEAT_JSCVT are: ID_AA64ISAR1_EL1.JSCVT, ID_ISAR6_EL1.JSCVT, ID_ISAR6.JSCVT.

$\triangle$ **FEAT_LRCPC, Load-Acquire RCpc instructions**. FEAT_LRCPC introduces three instructions to support the weaker *Release Consistency processor consistent* (RCpc) model that enables the reordering of a Store-Release followed by a Load-Acquire to a different address: LDAPR, LDAPRB, LDAPRH. These instructions are added to the A64 instruction set. The feature is mandatory in Armv8.3 implementations. The ID_AA64ISAR1_EL1.LRCPC field identifies the presence of FEAT_LRCPC.

$\triangle$ **FEAT_NV, Nested virtualization support**. FEAT_NV provides support for a Guest Hypervisor to run in Non-secure EL1 and ensures that the Guest Hypervisor is unaware that it is running at that Exception level. A Guest Hypervisor is supported regardless of the value of HCR_EL2.E2H. This feature is supported in AArch64 state only. The feature is OPTIONAL in Armv8.3 implementations. This feature must be implemented if FEAT_NV2 is implemented. The ID_AA64MMFR2_EL1.NV field identifies the presence of FEAT_NV.

$\triangle$ **FEAT_CCIDX, Extended cache index**. FEAT_CCIDX introduces the following registers to allow caches to be described with greater numbers of sets and greater associativity:
- A 64-bit format of CCSIDR_EL1.
- CCSIDR2_EL1.
- CCSIDR2.

This feature is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.3 implementations. The following fields identify the presence of FEAT_CCIDX: ID_AA64MMFR2_EL1.CCIDX, ID_MMFR4_EL1.CCIDX, ID_MMFR4.CCIDX.

$\triangle$ **FEAT_PAuth and FEAT_EPAC, Pointer authentication and Enhanced Pointer authentication**. FEAT_PAuth adds functionality that supports address authentication of the contents of a register before that register is used as the target of an indirect branch, or as a load. FEAT_EPAC adds functionality that permits setting the Pointer Authentication Code (PAC) field to 0 on performing a PAC operation on a non-canonical address. These features are supported in AArch64 state only. FEAT_PAuth is mandatory in Armv8.3 implementations. FEAT_EPAC is OPTIONAL in Armv8.3 implementations. When FEAT_PAuth is implemented, one of the following must be true:
- Exactly one of the PAC algorithms is implemented.
- If the PACGA instruction and other Pointer authentication instructions use different PAC algorithms, exactly two PAC algorithms are implemented.

The PAC algorithm features are: FEAT_PACQARMA5, FEAT_PACIMP, FEAT_PACQARMA3. The following fields identify the presence of FEAT_PAuth: ID_AA64ISAR1_EL1.{GPI, GPA, API, APA}, ID_AA64ISAR2_EL1.{GPA3, APA3}. The following fields identify the presence of FEAT_EPAC: ID_AA64ISAR1_EL1.{API, APA}, ID_AA64ISAR2_EL1.APA3.

$\triangle$ **FEAT_PACQARMA5, Pointer authentication - QARMA5 algorithm**. FEAT_PACQARMA5 adds the QARMA5 cryptographic algorithm for PAC calculation. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.3 implementations, and can be implemented only if FEAT_PAuth is implemented. The ID_AA64ISAR1_EL1.{GPA, APA} fields identify the support for FEAT_PACQARMA5.

$\triangle$ **FEAT_PACIMP, Pointer authentication - IMPLEMENTATION DEFINED algorithm**. FEAT_PACIMP permits an IMPLEMENTATION DEFINED cryptographic algorithm to be used for PAC calculation. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.3 implementations, and can be implemented only if FEAT_PAuth is implemented. The ID_AA64ISAR1_EL1.{GPI, API} fields identify the support for FEAT_PACIMP.

### A2.6.2 Additional requirements of Armv8.3

$\triangle$ If FEAT_PMUv3 is implemented, FEAT_PMUv3p4 is OPTIONAL in Armv8.3 implementations.

### A2.6.3 Features added to the Armv8.3 extension in later releases

$\triangle$ **FEAT_SPEv1p1, Armv8.3 Statistical Profiling Extensions**. FEAT_SPEv1p1 adds an Alignment Flag in the Events packet and filtering on this event using PMSEVFR_EL1, together with support for the profiling of Scalable Vector Extension operations. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.3 implementations. An Armv8.5 implementation that includes the Statistical Profiling Extension must include FEAT_SPEv1p1. The fields in ID_AA64DFR0_EL1.PMSVer identify the presence of FEAT_SPEv1p1. 

$\triangle$ **FEAT_DoPD, Debug over Powerdown**. FEAT_DoPD provides a debug programmers’ model where all debug and PMU registers are in the Core power domain, all CTI registers are in the Debug power domain. Power control is provided by a CoreSight Granular Power Requester (GPR) component. When the OPTIONAL powerup mechanism is implemented and this feature is implemented, the debugger makes power control requests for the Core power domain using a CoreSight Class 0x9 ROM Table block, instead of using EDRCR.COREPURQ. EDRCR.COREPURQ is not implemented. This feature is OPTIONAL in Armv8.3 implementations. When FEAT_DoPD is implemented:
- FEAT_DoubleLock is not implemented.
- FEAT_Debugv8p2 must be implemented.
- If PC Sample-based profiling is implemented, FEAT_PCSRv8p2 must be implemented.
- The optional Software Lock is not implemented by the architecturally defined debug components in the PE Core power domain.
- If an ETMv4 trace unit is implemented, the ETM must implement:
    - ETMv4.2 or later.
    - The Unified Power Domain Model.
- If FEAT_ETE is implemented, the trace unit always implements a single power domain.

The fields that identify the presence of FEAT_DoPD are: EDDEVID.DebugPower, CTIDEVARCH.REVISION.

$\triangle$ **FEAT_PAuth2, Enhancements to pointer authentication**. FEAT_PAuth2 adds enhanced pointer authentication functionality that changes the mechanism by which a PAC is added to the pointer. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.3 implementations and mandatory in Armv8.6 implementations. The fields that identify the support for FEAT_PAuth2 are: ID_AA64ISAR1_EL1.{API, APA}, ID_AA64ISAR2_EL1.APA3.

$\triangle$ **FEAT_FPAC and FEAT_FPACCOMBINE, Faulting on AUT\* instructions and combined pointer authentication instructions**. FEAT_FPAC introduces faulting on an AUT* instruction. FEAT_FPACCOMBINE introduces faulting on the combined instructions that perform pointer authentication. FEAT_FPAC is added as a further extension to FEAT_PAuth2. FEAT_FPACCOMBINE is added as a further extension to FEAT_FPAC. These features are supported in AArch64 state only. FEAT_FPAC is OPTIONAL in Armv8.3 implementations, and can be implemented only if FEAT_PAuth2 is implemented. FEAT_FPACCOMBINE is OPTIONAL in Armv8.3 implementations, and can be implemented only if FEAT_FPAC is implemented. The fields that identify the support for FEAT_FPAC and FEAT_FPACCOMBINE are: ID_AA64ISAR1_EL1.{API, APA}, ID_AA64ISAR2_EL1.APA3.

$\triangle$ **FEAT_PACQARMA3, Pointer authentication - QARMA3 algorithm**. FEAT_PACQARMA3 adds the QARMA3 cryptographic algorithm for PAC calculation. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.3 implementations, and can be implemented only if FEAT_PAuth is implemented. The ID_AA64ISAR2_EL1.{GPA3, APA3} fields identify the support for FEAT_PACQARMA3.

$\triangle$ **FEAT_CONSTPACFIELD, PAC algorithm enhancement**. FEAT_CONSTPACFIELD introduces functionality that permits an implementation with pointer authentication to use the value of bit[55] in the virtual address to determine the size of the PAC field, even when the top byte is not being ignored. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.3 implementations, and can be implemented only if FEAT_PAuth2 is implemented. The ID_AA64ISAR2_EL1.PAC_frac field identifies the support for FEAT_CONSTPACFIELD.

## A2.7 The Armv8.4 architecture extension

### A2.7.1 Architectural features added by Armv8.4

$\triangle$ An implementation of the Armv8.4 extension must include all of the features that this section describes as mandatory. Such an implementation is also called an implementation of the Armv8.4 architecture.

$\triangle$ **FEAT_DIT, Data Independent Timing instructions**. FEAT_DIT provides independent timing for data processing instructions with the addition of the PSTATE.DIT and CPSR.DIT fields. This feature is supported in both AArch64 and AArch32 states. This feature is mandatory in Armv8.4 implementations. The following fields identify the presence of FEAT_DIT: ID_AA64PFR0_EL1.DIT, ID_PFR0_EL1.DIT, ID_PFR0.DIT.

$\triangle$ **FEAT_FlagM, Flag manipulation instructions v2**. FEAT_FlagM provides instructions which manipulate the PSTATE.{N,Z,C,V} flags. These instructions are added to the A64 instruction set only. This feature is OPTIONAL in Armv8.2 implementations. This feature is mandatory in Armv8.4 implementations. The ID_AA64ISAR0_EL1.TS field identifies the presence of FEAT_FlagM.

$\triangle$ **FEAT_LRCPC2, Load-Acquire RCpc instructions v2**. FEAT_LRCPC2 provides versions of LDAPR and STLR with a 9-bit unscaled signed immediate offset. These instructions are added to the A64 instruction set only. This feature is OPTIONAL in Armv8.2 implementations. This feature is mandatory in Armv8.4 implementations. The ID_AA64ISAR1_EL1.LRCPC field identifies the presence of FEAT_LRCPC2.

$\triangle$ **FEAT_LSE2, Large System Extensions v2**. FEAT_LSE2 introduces changes to single-copy atomicity requirements for loads and stores, and changes to alignment requirements for loads and stores. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.2 implementations. This feature is mandatory in Armv8.4 implementations. The ID_AA64MMFR2_EL1.AT field identifies the presence of FEAT_LSE2.

$\triangle$ **FEAT_TLBIOS, TLB invalidate instructions in Outer Shareable domain**. FEAT_TLBIOS provides TLBI maintenance instructions that extend to the Outer Shareable domain. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.4 implementations. The field ID_AA64ISAR0_EL1.TLB identifies the presence of FEAT_TLBIOS.

$\triangle$ **FEAT_TLBIRANGE, TLB invalidate range instructions**. FEAT_TLBIRANGE provides TLBI maintenance instructions that apply to a range of input addresses. FEAT_TLBIRANGE being implemented implies that FEAT_TLBIOS is implemented. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.4 implementations. The field ID_AA64ISAR0_EL1.TLB identifies the presence of FEAT_TLBIRANGE.

$\triangle$ **FEAT_TTL, Translation Table Level**. FEAT_TTL provides the TTL field to indicate the level of translation table walk holding the leaf entry for the address that is being invalidated. This field is provided in all TLB maintenance instructions that take a VA or an IPA argument. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.4 implementations. The field ID_AA64MMFR2_EL1.TTL identifies the presence of FEAT_TTL.

$\triangle$ **FEAT_S2FWB, Stage 2 forced Write-Back**. FEAT_S2FWB reduces the requirement of additional cache maintenance instructions in systems where the data Cacheability attributes used by the Guest operating system are different from those expected by the Hypervisor. If this feature is implemented, there is no meaningful distinction between the Inner and Outer Shareability domains for accesses to Normal Cacheable memory. This feature is supported in AArch64 state. This feature is mandatory in Armv8.4 implementations that implement EL2. The ID_AA64MMFR2_EL1.FWB field identifies the presence of FEAT_S2FWB.

$\triangle$ **FEAT_TTST, Small translation tables**. FEAT_TTST relaxes the lower limit on the size of translation tables, by increasing the maximum permitted value of the T1SZ and T0SZ fields in TCR_EL1, TCR_EL2, TCR_EL3, VTCR_EL2 and VSTCR_EL2. This feature is supported in AArch64 state only. This feature is mandatory if FEAT_SEL2 is implemented. This feature is OPTIONAL if FEAT_SEL2 is not implemented. The ID_AA64MMFR2_EL1.ST field identifies the presence of FEAT_TTST.

$\triangle$ **FEAT_BBM, Translation table break-before-make levels**. FEAT_BBM provides support to identify the requirements of hardware to have break-before-make sequences when changing between block size for a translation. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.4 implementations. The ID_AA64MMFR2_EL1.BBM field identifies the presence of FEAT_BBM.

$\triangle$ **FEAT_SEL2, Secure EL2**. FEAT_SEL2 permits EL2 to be implemented in Secure state. When Secure EL2 is enabled, a translation regime is introduced that follows the same format as the other Secure translation regimes. This feature is not supported if EL2 is using AArch32. This feature is mandatory in Armv8.4 implementations that implement both EL2 and Secure state. The ID_AA64PFR0_EL1.SEL2 field identifies the presence of FEAT_SEL2.

$\triangle$ **FEAT_NV2, Enhanced nested virtualization support**. FEAT_NV2 supports nested virtualization by redirecting register accesses that would be trapped to EL1 and EL2 to access memory instead. The address of the memory access depends on information held in introduced register, VNCR_EL2. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.4 implementations. The ID_AA64MMFR2_EL1.NV field identifies the presence of FEAT_NV2.

$\triangle$ **FEAT_IDST, ID space trap handling**. FEAT_IDST causes all AArch64 read accesses to the feature ID space when exceptions are generated to be reported in ESR_ELx using the EC code 0x18. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.4 implementations. The ID_AA64MMFR2_EL1.IDS field identifies the presence of FEAT_IDST.

$\triangle$ **FEAT_CNTSC, Generic Counter Scaling**. FEAT_CNTSC adds a scaling register to the memory-mapped counter module that allows the frequency of the counter that is generated to be scaled from the basic frequency reported in the counter ID mechanisms. This feature is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.4 implementations. The CNTID.CNTSC field identifies the presence of FEAT_CNTSC.

$\triangle$ **FEAT_Debugv8p4, Debug v8.4**. FEAT_Debugv8p4 covers a selection of mandatory changes:
- The fields MDCR_EL3.{EPMAD, EDAD} control Non-secure access to the debug and PMU registers. The bus Requester is responsible for other debug authentication.
- The Software Lock is obsolete.
- Non-invasive Debug controls are relaxed.
- Secure and Non-secure views of the debug registers are enabled. 

This feature is mandatory if FEAT_SEL2 is implemented. The fields that identify the presence of FEAT_Debugv8p4 are: ID_AA64DFR0_EL1.DebugVer, DBGDIDR.Version, ID_DFR0_EL1.{CopSDbg, CopDbg}, ID_DFR0.{CopSDbg, CopDbg}, EDDEVARCH.ARCHID.

$\triangle$ **FEAT_TRF, Self-hosted Trace Extensions**. FEAT_TRF adds controls of trace in a self-hosted system through System registers. The feature provides:
- Control of Exception levels and Security states where trace generation is prohibited.
- Control of whether an offset is used for the timestamp recorded with trace information.
- A barrier instruction TSB CSYNC which can be used to prevent reordering of trace operation accesses with respect to other accesses of the same System registers.

If Armv8.4 and an ETM Architecture trace unit is implemented, this feature is mandatory. If this feature is implemented, the trace unit must include System register access to its control registers. The reset state of the PE has prohibited regions controlled by the feature and not the external authentication signals. An external trace controller must override the internal controls before enabling trace, including trace from reset. This is a change from previous trace architectures and is
not backwards-compatible. The fields that identify the presence of FEAT_TRF are: ID_AA64DFR0_EL1.TraceFilt, ID_DFR0_EL1.TraceFilt, ID_DFR0.TraceFilt, EDDFR.TraceVer, ID_AA64DFR0_EL1.TraceVer.

$\triangle$ **FEAT_PMUv3p4, PMU Extensions v3.4**. FEAT_PMUv3p4 introduces the PMMIR_EL1 and PMMIR registers. This feature is supported in both AArch64 and AArch32 states. The Performance Monitors Extension is an OPTIONAL feature, but if it is implemented, an Armv8.4 implementation must include FEAT_PMUv3p4. The fields that identify the presence of FEAT_PMUv3p4 are: ID_AA64DFR0_EL1.PMUVer, ID_DFR0_EL1.PerfMon, ID_DFR0.PerfMon, EDDFR.PMUVer.

$\triangle$ **FEAT_RASv1p1, RAS Extension v1.1**. FEAT_RASv1p1 implements RAS System Architecture v1.1 and adds support for:
- Simplifications to ERR\<n\>STATUS.
- Additional ERR\<n\>MISC\<m\> registers.
- The OPTIONAL RAS Common Fault Injection Model Extension.

This feature is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.2 implementations and mandatory in Armv8.4 implementations. The following fields identify the complete or partial presence of FEAT_RASv1p1: ID_AA64PFR0_EL1.RAS, ID_AA64PFR1_EL1.RAS_frac, ID_PFR0_EL1.RAS, ID_PFR2_EL1.RAS_frac, ID_PFR0.RAS, ID_PFR2.RAS_frac.

$\triangle$ **FEAT_DoubleFault, Double Fault Extension**. FEAT_DoubleFault provides two controls: SCR_EL3.EASE, SCR_EL3.NMEA. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.4 implementations if EL3 is implemented and EL3 uses AArch64. Otherwise, it is not implemented. This feature is implemented if ID_AA64PFR0_EL1.RAS >= `0b0010` and the implementation includes EL3 using AArch64.

### A2.7.2 Features added to earlier extensions

$\triangle$ The existing functionality of OS Double Lock is added as a feature mnemonic in Armv8.0.

## A2.8 The Armv8.5 architecture extension

### A2.8.1 Architectural features added by Armv8.5

$\triangle$ An implementation of the Armv8.5 extension must include all of the features that this section describes as mandatory. Such an implementation is also called an implementation of the Armv8.5 architecture.

$\triangle$ **FEAT_FlagM2, Enhancements to flag manipulation instructions**. FEAT_FlagM2 provides instructions that convert between the PSTATE condition flag format used by the FCMP instruction and an alternative format. These instructions are added to the A64 instruction set only. This feature is mandatory in Armv8.5 implementations. The ID_AA64ISAR0_EL1.TS field identifies the presence of FEAT_FlagM2.

$\triangle$ **FEAT_FRINTTS, Floating-point to integer instructions**. FEAT_FRINTTS provides instructions that round a floating-point number to an integral valued floating-point number that fits in a 32-bit or 64-bit integer number range. These instructions are added to the A64 instruction set only. This feature requires SIMD&FP, and is mandatory in Armv8.5 implementations when SIMD&FP is implemented. The ID_AA64ISAR1_EL1.FRINTTS identifies the presence of FEAT_FRINTTS.

$\triangle$ **FEAT_ExS, Context synchronization and exception handling**. FEAT_ExS provides a mechanism to control whether exception entry and exception return are context synchronization events. Fields in the SCTLR_ELx registers enable and disable context synchronization at exception entry and return at an Exception level. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.5 implementations. The ID_AA64MMFR0_EL1.ExS identifies the presence of FEAT_ExS.

$\triangle$ **FEAT_GTG, Guest translation granule size**. FEAT_GTG allows a hypervisor to support different granule sizes for stage 2 and stage 1 translation, and allows a nested hypervisor to determine what stage 2 granule sizes are available. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.5 implementations. The ID_AA64MMFR0_EL1.{TGran16_2, TGran64_2, TGran4_2} fields identify whether each of the granule sizes is supported for stage 2 translation. The ID_AA64MMFR0_EL1.{TGran16, TGran64, TGran4} fields identify whether each of the granule sizes is supported for stage 1 translations.

$\triangle$ **FEAT_BTI, Branch Target Identification**. FEAT_BTI allows memory pages to be guarded against the execution of instructions that are not the intended target of a branch. To do this, it introduces:
- The GP field, which denotes the blocks and pages in stage 1 translation tables that are guarded pages.
- The PSTATE.BTYPE field, which is used to determine whether an access to a guarded memory region will generate a Branch Target exception.
- The `BTI` instruction, which is used to guard against the execution of instructions that are not the intended target of a branch.

This feature is supported in AArch64 state only. This feature is mandatory in Armv8.5 implementations. The ID_AA64PFR1_EL1.BT field identifies the presence of FEAT_BTI.

$\triangle$ **FEAT_E0PD, Preventing EL0 access to halves of address maps**. FEAT_E0PD prevents access at EL0 to half of the addresses in the memory map. This feature is supported in AArch64 state only. When EL1 is using AArch64 state, this feature affects access to EL0, in either Execution state.  This feature is mandatory in Armv8.5 implementations. Implementations that support FEAT_E0PD must also support FEAT_CSV3. The ID_AA64MMFR2_EL1.E0PD field identifies presence of FEAT_E0PD.

$\triangle$ **FEAT_RNG, Random number generator**. FEAT_RNG introduces the RNDR and RNDRRS registers. Reads to these registers return a 64-bit random number. A read to RNDRRS will cause a reseeding of the random number before the generation of the random number that is returned. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.5 implementations. The ID_AA64ISAR0_EL1.RNDR field identifies presence of FEAT_RNG.

$\triangle$ **FEAT_MTE and FEAT_MTE2, Memory Tagging Extension**. FEAT_MTE and FEAT_MTE2 provide architectural support for runtime, always-on detection of various classes of memory error to aid with software debugging to eliminate vulnerabilities arising from memory-unsafe languages. These features are supported in AArch64 state only. These features are OPTIONAL in Armv8.5 implementations. The ID_AA64PFR1_EL1.MTE field identifies the presence of FEAT_MTE and FEAT_MTE2.

$\triangle$ **FEAT_PMUv3p5, PMU Extensions v3.5**. FEAT_PMUv3p5 extends event counters to 64-bit event counters, and adds mechanisms to disable the cycle counter in Secure state and in EL2. FEAT_PMUv3p5 relaxes the behavior of PMCR.{IMP, IDCODE}, and deprecates use of these fields. This feature is supported in both AArch64 and AArch32 states. The Performance Monitors Extension is an OPTIONAL feature, but if it is implemented, an Armv8.5 implementation must include FEAT_PMUv3p5. The fields that identify the presence of FEAT_PMUv3p5 are: ID_AA64DFR0_EL1.PMUVer, ID_DFR0_EL1.PerfMon, ID_DFR0.PerfMon, EDDFR.PMUVer.

### A2.8.2 Additional requirements of Armv8.5

$\triangle$ **Restrictions on effects of speculation**. Further restrictions are placed on execution for:
- Execution prediction instructions that predict addresses or register values.
- Data loaded under speculation with a permission or domain fault.
- Any System register read under speculation to a register that is not architecturally accessible from the current Exception level.

$\triangle$ **Changes to CTIDEVARCH, CTIDEVAFF0, and CTIDEVAFF1**. CTIDEVARCH, CTIDEVAFF0, and CTIDEVAFF1 must be implemented.

$\triangle$ **Changes to the input channel gate function**. If the *Cross Trigger Matrix* (CTM) is implemented, the input channel gate function must be implemented.

$\triangle$ **Deprecation of EDPRCR.CWRR**. EDPRCR.CWRR is deprecated.

### A2.8.3 Features added to earlier extensions

$\triangle$ The features that have been added to earlier architectural extensions are: FEAT_SB, FEAT_SSBS, FEAT_CSV2, FEAT_CSV3, FEAT_SPECRES, FEAT_CP15SDISABLE2, FEAT_EVT, FEAT_DPB2, FEAT_SPEv1p1, FEAT_DoPD.

### A2.8.4 Architectural requirements added to earlier extensions

$\triangle$ The additional architectural requirement that has been added to earlier extensions is Prefetch speculation protection.

### A2.8.5 Features added to the Armv8.5 extension in later releases

$\triangle$ **FEAT_MTE3, MTE Asymmetric Fault Handling**. FEAT_MTE3 introduces support for asymmetric Tag Check Fault handling. This feature is OPTIONAL in Armv8.5 implementations. This feature is mandatory from Armv8.7 when FEAT_MTE2 is implemented. This feature is supported in AArch64 state. The ID_AA64PFR1_EL1.MTE field identifies the presence of FEAT_MTE3.

$\triangle$ **FEAT_RNG_TRAP, Trapping support for RNDR/RNDRRS**. FEAT_RNG_TRAP introduces support for EL3 trapping of reads of the RNDR and RNDRRS registers. This feature is supported in AArch64 state. This feature is OPTIONAL in Armv8.5 implementations. The ID_AA64PFR1_EL1.RNDR_trap field identifies the presence of FEAT_RNG_TRAP.

## A2.9 The Armv8.6 architecture extension

### A2.9.1 Architectural features added by Armv8.6

$\triangle$ An implementation of the Armv8.6 extension must include all of the features that this section describes as mandatory. Such an implementation is also called an implementation of the Armv8.6 architecture.

$\triangle$ **FEAT_ECV, Enhanced Counter Virtualization**. FEAT_ECV enhances the Generic Timer architecture. When executing in AArch64 state or AArch32 state, FEAT_ECV provides:
- Self-synchronizing views of the virtual and physical timers in AArch64 and AArch32 state.
- The ability to scale the generation of the event stream.

When EL2 is using AArch64 state, FEAT_ECV provides:
- An optional offset between the EL1 or EL0 view of physical time, and the EL2 or EL3 view of physical time.
- Traps configurable in CNTHCTL_EL2 that trap EL0 and EL1 access to the virtual counter or timer registers, and accesses to the physical timer registers when they are accessed using an EL02 descriptor.

The optional offset to views of physical time, and the configurable traps in CNTHCTL_EL2, both apply to EL1 and EL0 whether EL1 and EL0 are in AArch64 state or AArch32 state. This feature is mandatory in Armv8.6 implementations. The ID_AA64MMFR0_EL1.ECV field identifies the presence of FEAT_ECV. The ID_PFR1_EL1.GenTimer and ID_PFR1.GenTimer fields identify support for self-synchronized counter views in AArch32 state.

$\triangle$ **FEAT_FGT, Fine Grain Traps**. FEAT_FGT introduces additional traps to EL2 of EL1 and EL0 access to individual or small groups of System registers and instructions, and traps to EL3 and EL2 of the Debug Communications Channel registers. The traps are independent of existing controls. This feature is supported in AArch64, and when EL1 is using AArch64, EL0 accesses using AArch32 are also trapped. This feature is mandatory in Armv8.6 implementations. The ID_AA64MMFR0_EL1.FGT field identifies the presence of FEAT_FGT. 

$\triangle$ **FEAT_TWED, Delayed Trapping of WFE**. FEAT_TWED introduces support for configurable delayed trapping of the WFE instruction. This feature is supported in both AArch64 and AArch32 states. This feature is OPTIONAL in Armv8.6 implementations. The ID_AA64MMFR1_EL1.TWED field identifies the presence of FEAT_TWED.

$\triangle$ **FEAT_AMUv1p1, AMU Extensions v1.1**. FEAT_AMUv1p1 introduces support for virtualization of Activity Monitors event counters, and introduces controls to disable access to auxiliary event counters below the highest Exception level. This feature is supported in AArch32 state and AArch64 state, if the hypervisor is using AArch64. This feature is OPTIONAL in Armv8.6 implementations if the OPTIONAL FEAT_AMUv1 is implemented. The fields ID_AA64PFR0_EL1.AMU, ID_PFR0_EL1.AMU, and ID_PFR0.AMU identify the presence of FEAT_AMUv1p1.

$\triangle$ **FEAT_MTPMU, Multi-threaded PMU Extensions**. FEAT_MTPMU introduces controls to disable PMEVTYPER\<n\>_EL0.MT. This feature requires at least one of EL2 and EL3. If neither is implemented, this feature is not implemented. If EL2 or EL3 is implemented, the feature is OPTIONAL if FEAT_PMUv3 is implemented. Multithreaded Armv8.6 implementations with FEAT_PMUv3 implemented must implement FEAT_MTPMU to enable any multithreaded event counting. This feature is supported in both AArch64 and AArch32 states. The fields ID_AA64DFR0_EL1.MTPMU and ID_DFR1.MTPMU identify the presence of FEAT_MTPMU.

### A2.9.2 Additional requirements of Armv8.6

$\triangle$ **Changes to the frequency of the physical counter**. The frequency of CNTFRQ_EL0 is standardized to a frequency of 1GHz. This means that the system counter must be implemented at 64 bits. 

### A2.9.3 Features added to earlier extensions

$\triangle$ The features that have been added to earlier architectural extensions are: FEAT_DGH, FEAT_ETS, FEAT_BF16, FEAT_AA32BF16, FEAT_I8MM, FEAT_AA32I8MM, FEAT_PAuth2, FEAT_FPAC.

## A2.10 The Armv8.7 architecture extension

### A2.10.1 Architectural features added by Armv8.7

$\triangle$ An implementation of the Armv8.7 extension must include all of the features that this section describes as mandatory. Such an implementation is also called an implementation of the Armv8.7 architecture.

$\triangle$ **FEAT_AFP, Alternate floating-point behavior**. FEAT_AFP allows alternate behavior for specified floating-point instructions including:
- Flushing of denormalized numbers to zero can be controlled separately on inputs and outputs.
- Alternate NaN propagation rules can apply.
- Output elements for specified scalar Advanced SIMD instructions can be determined using alternate rules.
- Changes to floating-point exception generation.

This feature is supported in AArch64 state only. This feature is mandatory in Armv8.7 implementations that implement floating-point support. The ID_AA64MMFR1_EL1.AFP field identifies the presence of FEAT_AFP.

$\triangle$ **FEAT_RPRES, Increased precision of Reciprocal Estimate and Reciprocal Square Root Estimate**. FEAT_RPRES allows an increase in the precision of the Reciprocal Estimate and Reciprocal Square Root Estimate from an 8-bit mantissa to a 12-bit mantissa. This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.7 implementations. This feature requires implementation of FEAT_AFP. The ID_AA64ISAR2_EL1.RPRES field identifies the presence of FEAT_RPRES.

$\triangle$ **FEAT_LS64, FEAT_LS64_V, FEAT_LS64_ACCDATA, Support for 64 byte loads/stores**. FEAT_LS64 introduces support for atomic single-copy 64-byte loads and stores without return. FEAT_LS64_V introduces support for atomic single-copy 64-byte stores with return. FEAT_LS64_ACCDATA introduces support for atomic single-copy 64-byte EL0 stores with return. These features are supported in AArch64 state only. FEAT_LS64 is OPTIONAL in Armv8.7 implementations. FEAT_LS64_V is OPTIONAL in Armv8.7 implementations, and can be implemented only if FEAT_LS64 is implemented. FEAT_LS64_ACCDATA is OPTIONAL in Armv8.7 implementations, and can be implemented only if FEAT_LS64_V is implemented. The ID_AA64ISAR1_EL1.LS64 field identifies the presence of FEAT_LS64, FEAT_LS64_V, and FEAT_LS64_ACCDATA.

$\triangle$ The meaning of any values being returned by the ST64BV and ST64BV0 instructions are retrospectively relaxed such that they are defined by the peripheral providing the response.

$\triangle$ **FEAT_WFxT, `WFE` and `WFI` instructions with timeout**. FEAT_WFxT introduces `WFET` and `WFIT`. These instructions support the generation of a local timeout event to act as a wake-up event for the PE when the virtual count in CNTVCT_EL0 equals or exceeds the value supplied by the instruction for the first time. The register number that holds the timeout value for trapped `WFET` and `WFIT` instructions is reported in ESR_ELx. These instructions are added to the A64 instruction set only. FEAT_WFxT is mandatory in Armv8.7 implementations. The ID_AA64ISAR2_EL1.WFxT field identifies the presence of FEAT_WFxT.

$\triangle$ **FEAT_HCX, Support for the HCRX_EL2 register**. FEAT_HCX introduces the Extended Hypervisor Configuration Register, HCRX_EL2, that provides configuration controls for virtualization in addition to those provided by HCR_EL2, including defining whether various operations are trapped to EL2. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.7 implementations. The ID_AA64MMFR1_EL1.HCX field identifies the presence of FEAT_HCX.

$\triangle$ **FEAT_LPA2, Larger physical address for 4KB and 16KB translation granules**. FEAT_LPA2:
- Allows a larger VA space for each translation table base register of up to 52 bits when using the 4KB or 16KB translation granules.
- Allows a larger intermediate physical address (IPA) and PA space of up to 52 bits when using the 4KB or 16KB translation granules.
- Allows a level 0 block size where the block covers a 512GB address range for the 4KB translation granule if the implementation supports 52 bits of PA.
- Allows a level 1 block size where the block covers a 64GB address range for the 16KB translation granule if the implementation supports 52 bits of PA.

This feature is supported in AArch64 state only. This feature is OPTIONAL in Armv8.7 implementations. This feature requires implementation of FEAT_LPA and FEAT_LVA. The ID_AA64MMFR0_EL1.{TGRAN4_2, TGRAN16_2, TGRAN4, TGRAN16} fields identify the presence of FEAT_LPA2.

$\triangle$ **FEAT_XS, XS attribute**. FEAT_XS introduces the XS attribute for memory to indicate that an access could take a long time to complete. This feature provides variants of DSB instructions and TLB maintenance instructions, the completion of which does not depend on the completion of memory accesses with the XS attribute. FEAT_XS adds:
- A mechanism to define the XS attribute for memory.
- An optional nXS variant to the AArch64 DSB instruction and optional nXS qualifier to each AArch64 TLBI instruction to handle memory accesses with the XS attribute.
- The FGTnXS bit to HCRX_EL2 to determine the behavior of fine-grained traps in HFGITR_EL2 for TLB maintenance instructions with the nXS qualifier.
- The FnXS bit to HCRX_EL2 to determine the behavior of pre-existing TLB maintenance instructions in relation to the XS attribute.

This feature is supported in AArch64 state only, but the XS attribute also impacts AArch32 state execution. This feature is mandatory in Armv8.7 implementations. The ID_AA64ISAR1_EL1.XS field identifies the presence of FEAT_XS.

$\triangle$ **FEAT_PMUv3p7, Armv8.7 PMU extensions**. FEAT_PMUv3p7 adds the following features to the Performance Monitors Extension:
- PMU counters can be frozen when an event counter has an unsigned overflow.
- Event counters can be prohibited from counting events at EL3 without affecting the rest of Secure state.
- The cycle counter can be prohibited from counting cycles at EL3 without affecting the rest of Secure state.

This feature is supported in both AArch64 and AArch32 states. The Performance Monitors Extension is an OPTIONAL feature, but if it is implemented, an Armv8.7 implementation must include FEAT_PMUv3p7. The fields that identify the presence of FEAT_PMUv3p7 are: ID_AA64DFR0_EL1.PMUVer, ID_DFR0_EL1.PerfMon, ID_DFR0.PerfMon, EDDFR.PMUVer.

$\triangle$ **FEAT_SPEv1p2, Armv8.7 SPE features**. FEAT_SPEv1p2 adds the following features to the Statistical Profiling Extension, FEAT_SPE:
- Adds an inverse event filter control.
- Adds controls to freeze the PMU event counters after an SPE buffer management event occurs.
- Adds a discard mode that allows all SPE data to be discarded rather than written to memory.

This feature is mandatory from Armv8.7 when FEAT_SPE is implemented. This feature is supported in AArch64 state. FEAT_SPEv1p2 optionally enables support for a packet for each taken branch that provides the target address for the previous taken branch. ID_AA64DFR0_EL1.PMSVer identifies the presence of FEAT_SPEv1p2. If FEAT_SPEv1p2 is implemented, PMSIDR_EL1.PBT indicates support for the previous branch target packet.

### A2.10.2 Additional requirements of Armv8.7

$\triangle$ **FEAT_ETS, Enhanced Translation Synchronization**. All implementations of the Armv8.7 architecture are required to implement FEAT_ETS.

### A2.10.3 Features added to earlier extensions

$\triangle$ The features that have been added to earlier architectural extensions are: FEAT_PAN3, FEAT_MTE3.

## A2.11 The Armv8.8 architecture extension

### A2.11.1 Architectural features added by Armv8.8
$\triangle$ An implementation of the Armv8.8 extension must include all of the features that this section describes as mandatory. Such an implementation is also called an implementation of the Armv8.8 architecture.

$\triangle$ **FEAT_MOPS, Standardization of memory operations**. FEAT_MOPS provides instructions that perform a memory copy or memory set, and adds Memory Copy and Memory Set exceptions. FEAT_MOPS also adds the HCRX_EL2.{MSCEn, MCE2}, SCTLR_EL1.MSCEn, and SCTLR_EL2.MSCEn control bits. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.8 implementations. The ID_AA64ISAR2_EL1.MOPS field identifies the presence of FEAT_MOPS.

$\triangle$ **FEAT_HBC, Hinted conditional branches**. FEAT_HBC provides the BC.cond instruction to give a conditional branch with a hint to branch prediction logic that this branch will consistently and is highly unlikely to change direction. This feature is supported in AArch64 state only. This feature is mandatory in Armv8.8 implementations. The ID_AA64ISAR2_EL1.BC field identifies the presence of FEAT_HBC.

$\triangle$ **FEAT_NMI, Non-maskable Interrupts**. FEAT_NMI provides a mechanism to support *non-maskable interrupts* (NMI) and *less-masked interrupts* (LMI). In addition to legacy behavior, the feature includes the following:
- A mode for supporting an LMI interrupt mask that is distinct from PSTATE.{I, F}.
- A mode for supporting a limited NMI, where the value when PSTATE.SP is 1 is taken as an interrupt mask for all interrupts targeting that Exception level, and where the LMI interrupt mask can also be used.
  
FEAT_NMI adds:
- The `AllIntMask` variable.
- An optional Superpriority attribute to denote virtual and physical IRQ and FIQ interrupts as non-maskable.
- The SCTLR_ELx.{NMI, SPINTMASK} control bits.
- The PSTATE.ALLINT bit and associated instructions.
- The HCRX_EL2.TALLINT bit to enable trapping of ALLINT instructions at EL1.

This feature is supported in AArch64 state only. This feature is mandatory in Armv8.8 implementations. The ID_AA64PFR1_EL1.NMI field identifies the presence of FEAT_NMI.

$\triangle$ **FEAT_TIDCP1, EL0 use of IMPLEMENTATION DEFINED functionality**. FEAT_TIDCP1 adds a control at EL1 and EL2 to enable trapping of EL0 accesses to registers that might control IMPLEMENTATION DEFINED functions. This feature adds controls only in AArch64 state, and controls IMPLEMENTATION DEFINED execution at EL0 in both AArch32 and AArch64 states. This feature is mandatory in Armv8.8 implementations. The ID_AA64MMFR1_EL1.TIDCP1 field identifies the presence of FEAT_TIDCP1.

$\triangle$ **FEAT_CMOW, Control for cache maintenance permission**. FEAT_CMOW introduces support for cache maintenance instructions that controls whether:
- Cache maintenance instructions executed at EL0 require stage 1 read and write permission to prevent the instructions from generating a Permission fault.
-  Cache maintenance instructions executed at EL1 or EL0 require stage 2 read and write permission to prevent the instructions from generating a Permission fault.

This feature is supported in AArch64 state only, but also impacts AArch32 instructions. This feature is mandatory in Armv8.8 implementations. The ID_AA64MMFR1_EL1.CMOW field identifies the presence of FEAT_CMOW.

$\triangle$ **FEAT_PMUv3p8, Armv8.8 PMU extensions**. FEAT_PMUv3p8 adds the following features to the Performance Monitors Extension:
- The Common event number space is extended to include the ranges `0x0040-0x00BF` and `0x4040-0x40BF`.
- For an event counter *n*, if any reserved or unimplemented PMU event number is written to PMEVTYPER<n>.evtCount, the event counter *n* does not count, and a read of PMEVTYPER<n>.evtCount returns the value written.

This feature is supported in both AArch64 and AArch32 states. The Performance Monitors Extension is an OPTIONAL feature, but if it is implemented, an Armv8.8 implementation must include FEAT_PMUv3p8. The fields that identify the presence of FEAT_PMUv3p8 are: ID_AA64DFR0_EL1.PMUVer, ID_DFR0_EL1.PerfMon, ID_DFR0.PerfMon, EDDFR.PMUVer.

$\triangle$ **FEAT_HPMN0, Setting of MDCR_EL2.HPMN to zero**. FEAT_HPMN0 permits a hypervisor to provide zero PMU event counters for a guest operating system by setting MDCR_EL2.HPMN to zero. This feature is supported in both AArch64 and AArch32 states. This feature is mandatory in Armv8.8 implementations that include FEAT_PMUv3 and EL2. Otherwise, this feature is OPTIONAL in implementations that include FEAT_PMUv3, FEAT_FGT, and EL2. The fields that identify the presence of FEAT_HPMN0 are: ID_AA64DFR0_EL1.HPMN0, ID_DFR1_EL1.HPMN0, ID_DFR1.HPMN0.

$\triangle$ **FEAT_PMUv3_TH, Event counting threshold**. FEAT_PMUv3_TH adds threshold condition controls to each PMEVTYPER<n>_EL0 register. This feature permits the counter to count only when PMEVTYPER<n>.{MT, evtCount} describes an event whose count meets a specified threshold condition. This feature is supported in both AArch64 and AArch32 states. The threshold condition controls are only accessible in AArch64 state. However, threshold conditions still apply in AArch32 state. This feature is OPTIONAL in Armv8.8 implementations. This feature requires FEAT_PMUv3 to be implemented, and AArch64 state to be supported. The fields that identify the presence of FEAT_PMUv3_TH are: PMMIR_EL1.THWIDTH, PMMIR.THWIDTH, If the external debug interface to the PMU registers is implemented, PMMIR.THWIDTH.

$\triangle$ **FEAT_SPEv1p3, Armv8.8 Statistical Profiling Extensions**. FEAT_SPEv1p3 adds the following features to the Statistical Profiling Extension:
- Support for sampling Tag operations.
- Support for sampling Memory Copy and Set operations.

This feature is supported in both AArch64 and AArch32 states. This feature is mandatory from Armv8.8 when FEAT_SPE is implemented. The ID_AA64DFR0_EL1.PMSVer field identifies the presence of FEAT_SPEv1p3.

$\triangle$ **FEAT_Debugv8p8, Debug v8.8**. FEAT_Debugv8p8 adds support to allow an asynchronous exception to be taken after an exception generates an Exception Catch debug event, but before the PE halts. This feature is supported in both AArch64 and AArch32 states. This feature is mandatory in Armv8.8 implementations. The fields that identify the presence of FEAT_Debugv8p8 are: ID_AA64DFR0_EL1.DebugVer, ID_DFR0.CopDbg, DBGDIDR.Version, EDDEVARCH.ARCHID.

### A2.11.2 Additional requirements of Armv8.8

$\triangle$ **Access Flag and dirty state management by SPE**. Removal of the option for the Access Flag and dirty state to behave as if always disabled for accesses made by the SPU. 

$\triangle$ **External abort handling by SPE**. External aborts on writes made by the SPU must generate SError interrupt exceptions. 

$\triangle$ **64-bit external PMU programmers’ model extension**. The 64-bit external PMU programmers’ model extension extends the Performance Monitors registers to 64 bits, except the 32-bit CoreSight management registers. This extension is supported in both AArch64 and AArch32 states. This extension is OPTIONAL when the external debug interface to the Performance Monitors is implemented. This extension requires the external debug interface to the Performance Monitors to be implemented, and AArch64 state to be supported. The PMDEVARCH.ARCHPART field indicates the presence of the 64-bit external PMU programmers’ model extension.

### A2.11.3 Features added to earlier extensions

The features that have been added to earlier architectural extensions are: FEAT_PACQARMA3, FEAT_CONSTPACFIELD, FEAT_RNG_TRAP.

## A2.12 The Performance Monitors Extension

$\triangle$ The Performance Monitors Extension, FEAT_PMUv3, is an OPTIONAL extension but Arm strongly recommends that Armv8-A implementations include version 3 of the Performance Monitors Extension.

$\triangle$ ID_AA64DFR0_EL1.PMUVer indicates whether the Performance Monitors Extension is implemented.

$\triangle$ Armv8.1 introduces the following architectural feature to the Performance Monitors Extension: FEAT_PMUv3p1.

$\triangle$ Armv8.4 introduces the following architectural feature to the Performance Monitors Extension: FEAT_PMUv3p4.

$\triangle$ Armv8.5 introduces the following architectural feature to the Performance Monitors Extension: FEAT_PMUv3p5.

$\triangle$ Armv8.6 introduces the following architectural feature to the Performance Monitors Extension: FEAT_MTPMU.

$\triangle$ Armv8.7 introduces the following architectural feature to the Performance Monitors Extension: FEAT_PMUv3p7.

$\triangle$ Armv8.8 introduces the following architectural features to the Performance Monitors Extension: FEAT_PMUv3p8, FEAT_HPMN0, FEAT_PMUv3_TH.

## A2.13 The Reliability, Availability, and Serviceability Extension

$\triangle$ The RAS Extension, FEAT_RAS, is a mandatory extension to the Armv8.2 architecture, and an OPTIONAL extension to the Armv8.0 and the Armv8.1 architectures.

$\triangle$ The RAS Extension improves the dependability of a system by providing:
- Reliability, that is, the continuity of correct service.
- Availability, that is, the readiness for correct service.
- Serviceability, that is, the ability to undergo modifications and repairs.

$\triangle$ ID_AA64PFR0_EL1.RAS in AArch64 state, and ID_PFR0.RAS in AArch32 state, indicate whether the RAS Extension is implemented.

$\triangle$ The RAS Extension introduces a barrier instruction, the Error Synchronization Barrier (`ESB`), to the A32, T32, and A64 instruction sets.

$\triangle$ In addition, the RAS Extension introduces a number of memory-mapped registers. 

$\triangle$ Armv8.2 introduces the following architectural features to the RAS Extension: FEAT_IESB.

$\triangle$ Armv8.4 introduces the following architectural features to the RAS Extension: FEAT_RASv1p1, FEAT_DoubleFault.

## A2.14 The Statistical Profiling Extension (SPE)

$\triangle$ The Statistical Profiling Extension, FEAT_SPE, is an OPTIONAL extension introduced by the Armv8.2 architecture. Implementation of the Statistical Profiling Extension requires implementation of at least Armv8.1 of the Armv8-A architecture profile. The Statistical Profiling Extension is supported only in AArch64 state.

$\triangle$ The Statistical Profiling Extension provides a non-invasive method of sampling software and hardware using randomized sampling of either architectural instructions, as defined by the instruction set architecture, or by microarchitectural operations.

$\triangle$ ID_AA64DFR0_EL1.PMSVer indicates whether the Statistical Profiling Extension is implemented.

$\triangle$ Armv8.3 introduces the following architectural feature to the SPE: FEAT_SPEv1p1.

$\triangle$ Armv8.7 introduces the following architectural feature to the SPE: FEAT_SPEv1p2.

$\triangle$ Armv8.8 introduces the following architectural feature to the SPE: FEAT_SPEv1p3.

## A2.15 The Scalable Vector Extension (SVE)

$\triangle$ The Scalable Vector Extension, FEAT_SVE, is an OPTIONAL extension introduced by the Armv8.2 architecture. SVE is supported in AArch64 state only. 

$\triangle$ The Scalable Vector Extension includes the following functionality:
- Configurable vector length with scalable vector lengths from 128 bits up to 2048 bits.
- Predication using scalable predicate registers from 16 bits up to 256 bits.
- Instructions that operate on scalable size vectors and predicates.
- Gather-load and scatter-store.
- Software-managed speculative vectorization.
- System registers and fields to configure the Effective SVE vector length and traps.

$\triangle$ ID_AA64PFR0_EL1.SVE indicates whether the Scalable Vector Extension is implemented.

$\triangle$ The Scalable Vector Extension complements the AArch64 Advanced SIMD and floating-point functionality. SVE does not replace the AArch64 Advanced SIMD and floating-point functionality.

$\triangle$ Implementation of FEAT_SVE requires implementation of FEAT_FCMA and FEAT_FP16.

## A2.16 The Activity Monitors Extension (AMU)

$\triangle$ The Activity Monitors Extension is an OPTIONAL extension introduced by the Armv8.4 architecture. AMU is supported in AArch64 and AArch32 states.

$\triangle$ The Activity Monitors Extension implements version 1 of the Activity Monitors architecture, FEAT_AMUv1, which provides a function similar to a subset of the existing Performance Monitors Extension functionality, intended for system management use rather than debugging and profiling.

$\triangle$ The Activity Monitors Extension implements a System register interface to the Activity Monitors registers, and supports an optional external memory-mapped interface.

$\triangle$ The fields that identify the presence of the Activity Monitors Extension are: ID_AA64PFR0_EL1.AMU, ID_PFR0_EL1.AMU, ID_PFR0.AMU, EDPFR.AMU.

$\triangle$ Armv8.6 introduces the following architectural feature to the Activity Monitors Extension: FEAT_AMUv1p1.

## A2.17 The Memory Partitioning and Monitoring (MPAM) Extension

$\triangle$ The MPAM Extension, FEAT_MPAM, is an OPTIONAL extension introduced by the Armv8.4 architecture and requires implementation of at least Armv8.2 of the Armv8-A architecture profile. MPAM is supported in AArch64 state only.

$\triangle$ The MPAM Extension provides a framework for memory-system component controls that partition one or more of the performance resources of the component.

$\triangle$ The fields that identify the presence of the MPAM Extension are: ID_AA64PFR0_EL1.MPAM, EDPFR.MPAM.
