# Chapter C3 A64 Instruction Set Overview

## C3.1 Branches, Exception generating, and System Instructions

$\triangle$ Software must:
- Use only `BLR` or `BL` to perform a nested subroutine call when the subroutine is expected to return to the immediately following instruction, that is the instruction with the address of the `BLR` or `BL` instruction incremented by four.
- Use only `RET` to perform a subroutine return, when the subroutine is expected to have been entered by a `BL` or `BLR` instruction.
- Use only `B`, `BR` or the instruction listed in Table C3-1 to perform a control transfer that is not a subroutine call or subroutine return described in this Note.

### C3.1.1 Conditional branch

$\triangle$ Conditional branches change the flow of execution depending on the current state of the Condition flags or the value in a general-purpose register.

###### Table C3-1 Conditional branch instructions

$\triangle$ `B.cond`, `BC.cond`, `CBNZ`, `CBZ`, `TBNZ`, `TBZ`.

### C3.1.2 Unconditional branch (immediate)

$\triangle$ Unconditional branch (immediate) instructions change the flow of execution unconditionally by adding an immediate offset with a range of $\pm$ 128MB to the value of the program counter that fetched the instruction. The `BL` instruction also writes the address of the sequentially following instruction to general-purpose register X30.

###### Table C3-2 Unconditional branch instructions (immediate)

$\triangle$ `B`, `BL`.

### C3.1.3 Unconditional branch (register)

$\triangle$ Unconditional branch (register) instructions change the flow of execution unconditionally by setting the program counter to the value in a general-purpose register. The `BLR` instruction also writes the address of the sequentially following instruction to a general-purpose register X30. THe `RET` instruction behaves identically to `BR`, but provides an additional hint to the PE that this is a return from subroutine.

###### Table C3-3 Unconditional branch instructions (register)

$\triangle$ `BLR`, `BR`, `RET`.

### C3.1.4 Exception generation and return.

#### Exception generating

###### Table C3-4 Exception generation instruction

$\triangle$ `BRK`, `HLT`, `HVC`, `SMC`, `SVC`.

#### Exception return

###### Table C3-5 Exception return instruction

$\triangle$ `ERET`.

#### Debug state

###### Table C3-6 Debug state instructions

$\triangle$ `DCPS1`, `DCPS2`, `DCPS3`, `DRPS`.

### C3.1.5 System register instructions

###### Table C3-7 System register instructions

$\triangle$ `MRS`, `MSR`.

### C3.1.6 Instructions with register argument

###### Table C3-8 Instructions with register argument

$\triangle$ `WFET`, `WFIT`.

### C3.1.7 System Instructions

###### Table C3-9 System instructions

$\triangle$ `SYS`, `SYSL`, `IC`, `DC`, `AT`, `TLBI`.

### C3.1.8 Hint Instructions

###### Table C3-10 Hint instructions

$\triangle$ `NOP`, `YIELD`, `WFE`, `WFI`, `SEV`, `SEVL`, `HINT`, `DGH`.

### C3.1.9 Barriers and CLREX instructions

###### Table C3-11 Barriers and CLREX instructions.

$\triangle$ `CLREX`, `DMB`, `DSB`, `ISB`.

###### Table C3-12 Speculation and synchronization barriers

$\triangle$ `CSDB`, `ESB`, `PSB CSYNC`, `PSSBB`, `SB`, `SSBB`, `TSB CYNC`.

### C3.1.10 Pointer authentication instructions

#### Basic pointer authentication instructions

$\triangle$ Each of these instructions only performs an operation that supports pointer authentication.

###### Table C3-13 Instructions that add a PAC

$\triangle$ `PACIASP`, `PACIAZ`, `PACIA1716`, `PACIBSP`, `PACIBZ`, `PACIB1716`, `PACIA`, `PACDA`, `PACIB`, `PACDB`, `PACIZA`, `PACDZA`, `PACIZB`, `PACDZB`, `PACGA`.

###### Table C3-14 Instructions that authenticate a PAC

$\triangle$ `AUTIASP`, `AUTIAZ`, `AUTIA1716`, `AUTIBSP`, `AUTIBZ`, `AUTIB1716`, `AUTIA`, `AUTDA`, `AUTIB`, `AUTDB`, `AUTIZA`, `AUTDZA`, `AUTIZB`, `AUTDZB`.

###### Table C3-15 Instructions that strip a PAC

$\triangle$ `XPACLRI`, `XPACI`, `XPACD`.

#### Combined instructions that include pointer authentication

$\triangle$ Each of these instructions combines a pointer authentication with another operation that use the authenticated pointer.

###### Table C3-16 Combined pointer authentication instructions

$\triangle$ `RETAA`, `RETAB`, `BRAA`, `BRAB`, `BLRAA`, `BLRAB`, `BRAAZ`, `BRABZ`, `BLRAAZ`, `BLRABZ`, `ERETAA`, `ERETAB`, `LDRAA`, `LDRAB`.

## C3.2 Loads and stores

$\triangle$ The requirements for the alignment of data memory accesses are strict.

$\triangle$ The additional control bits SCTLR_ELx.SA and SCTLR_EL1.SA0 control whether the stack pointer must be quadword aligned when used as a base register. Using a misaligned stack pointer generates an SP alignment fault exception.

$\triangle$ In some cases, load/store instructions can lead to CONSTRAINED UNPREDICTABLE behavior.

### C3.2.1 Load/store register

$\triangle$ The load/store register instructions support the following addressing modes:
- Base plus a scaled 12-bit unsigned immediate offset or base plus an unscaled 9-bit signed immediate offset.
- Base plus a 64-bit register offset, optionally scaled.
- Base plus a 32-bit extended register offset, optionally scaled.
- Pre-indexed by an unscaled 9-bit signed immediate offset.
- Post-indexed by an unscaled 9-bit signed immediate offset.
- PC-relative literal for loads of 32b bits or more.

$\triangle$ If a Load instruction specifies writeback and the register being loaded is also the base register, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs the load using the specified addressing mode and the base register becomes UNKNOWN. In addition, if an exception occurs during the execution of such an instruction, the base address might be corrupted so that the instruction cannot be repeated.

$\triangle$ If a Store instruction performs a writeback and the register that is stored is also the base register, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs the store to the designated register using the specified addressing mode, but the value stored is UNKNOWN.

> NOTE: 这样定义的原因是什么？有点奇怪。

###### Table C3-17 Load/store register instructions

$\triangle$ `LDR`, `LDRB`, `LDRSB`, `LDRH`, `LDRSH`, `LDRSW`, `STR`, `STRB`, `STRH`.

### C3.2.2 Load/store register (unscaled offset)

$\triangle$ The load/store register instructions with an unscaled offset support only one addressing mode: Base plus an unscaled 9-bit signed immediate offset.

$\triangle$ The load/store register (unscaled offset) instructions are required to disambiguate this instruction class from the load/store register instruction forms that support an addressing mode of base plus a scaled, unsigned 12-bit immediate offset, because that can represent some offset values in the same range.

$\triangle$ The ambiguous immediate offsets are byte offsets that are both:
- In the range 0-255, inclusive.
- Naturally aligned to the access size.

$\triangle$ Other byte offsets in the range -256 to 255 inclusive are unambiguous, An assembler program translating a load/store instruction. Arm recommends that a disassembler outputs all unscaled 9-bit offset forms using one of these mnemonics, but unambiguous offsets can be output using a load/store single register mnemonic, for example, `LDR`.

###### Table C3-18 Load/store register (unscaled offset) instructions

$\triangle$ `LDUR`, `LDURB`, `LDURSB`, `LDURH`, `LDURSH`, `LDURSW`, `STUR`, `STURB`, `STURH`.

### C3.2.3 Load/store pair

$\triangle$ The load/store pair instructions support the following addressing modes:
- Base plus a scaled 7-bit signed immediate offset.
- Pre-indexed by scaled 7-bit signed immediate offset.
- Post-indexed by scaled 7-bit signed immediate offset.

$\triangle$ If a Load Pair instruction specifies the same register for the two registers that are being loaded, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all the loads using the specified addressing mode and the register that is loaded takes an UNKNOWN value.

$\triangle$ If a Load Pair instruction specifies writeback and one of the registers being loaded is also the base register, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all of the loads using the specified addressing mode, and the base register becomes UNKNOWN. In addition, if an exception occurs during the instruction, the base address might be corrupted so that the instruction cannot be repeated.

$\triangle$ If a Store Pair instruction performs a writeback and one of the registers being stored is also the base register, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all the stores of the registers indicated by the specified addressing mode, but the value stored for the base register is UNKNOWN.

###### Table C3-19 Load/store pair instructions

$\triangle$ `LDP`, `LDPSW`, `STP`.

### C3.2.4 Load/store non-temporal pair

$\triangle$ The load/store non-temporal pair instruction support only one address mode: Base plus a scaled 7-bit signed immediate offset.

$\triangle$ The load/store non-temporal pair instructions provide a hint to the memory system that an access is non-temporal or streaming, and unlikely to be repeated in the near feature. This means that data caching is not required. However, depending on the memory type, the instructions might permit memory reads to be preloaded and memory writes to be gathered to accelerate bulk memory transfers. 

> NOTE: 没有时间局部性，不需要进入缓存；可以预取，可以合并。

$\triangle$ If a Load Non-Temporal Pair instruction specifies the same register for the two registers that are being loaded, then behavior is CONSTRAINED UNPREDICTABLE and one of the following must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all the loads using the specified addressing mode and the register that is loaded takes an UNKNOWN value.

###### Table C3-20 Load/store non-temporal pair instructions

$\triangle$ `LDNP`, `STNP`.

### C3.2.5 Load/store unprivileged

$\triangle$ The load/store unprivileged instructions support only one addressing mode: Base plus an unscaled 9-bit signed immediate offset.

$\triangle$ The access permissions that apply to accesses made at EL0 applying to the memory accesses made by a load/store unprivileged instruction that is executed either:
- At EL1 when the *Effective value* of PSTATE.UAO is 0.
- At EL2 when both the *Effective value* of HCR_EL2.{E2H, TGE} is {1, 1} and the *Effective value* of PSTATE.UAO is 0.

$\triangle$ Otherwise, memory accesses made by a load/store unprivileged instruction are subject to the access permissions that apply to the Exception level at which the instruction is executed. There are the permissions that apply to the corresponding load/store register instruction.

$\triangle$ This means that when the value of PSTATE.UAO is 1 the access permissions for a load/store unprivileged instruction are always the same as those for the corresponding load/store register instruction.

###### Table C3-21 Load-Store unprivileged instructions

$\triangle$ `LDTR`, `LDTRB`, `LDTRSB`, `LDTRH`, `LDTRSH`, `LDTRSW`, `STTR`, `STTRB`, `STTRH`.

### C3.2.6 Load-Exclusive/Store-Exclusive

$\triangle$ The Load-Exclusive/Store-Exclusive instructions support only one addressing mode: Base register with no offset.

$\triangle$ The Load-Exclusive instructions mark the physical address being accessed as an exclusive access. The exclusive access mark is checked by teh Store-Exclusive instruction, permitting the construction of atomic read-modify-write operations on shared memory variables, semaphores, mutexes, and spinlocks.

$\triangle$ If FEAT_LSE2 is not implemented that:
- The Load-Exclusive/Store-Exclusive instructions other than Load-Exclusive pair and Store-Exclusive pair require natural alignment, and an unaligned address generates an Alignment fault.
- Memory accesses generated by Load-Exclusive pair or Store-Exclusive pair instructions must be aligned to the size of the pair, otherwise the access generates an Alignment fault.

$\triangle$ When a Store-Exclusive pair succeeds, it causes a single-copy atomic update of the entire memory location being stored to.

###### Table C3-22 Load-Exclusive/Store-Exclusive instructions

$\triangle$ `LDXR`, `LDXRB`, `LDXRH`, `LDXP`, `STXR`, `STXRB`, `STXRH`, `STXP`.

### C3.2.7 Load-Acquire/Store-Release

$\triangle$ The Load-Acquire, Load-AcquirePC, and Store-Release instructions support only one addressing mode: Base register with no offset.

$\triangle$ The Load-Acquire, Load-AcquirePC, and Store-Release instructions can remove the requirement to use the explicit DMB memory barrier instruction.

$\triangle$ The Load-Acquire, Load-AcquirePC, and Store-Release instructions other than Load-Acquire pair and Store-Release pair require natural alignment, and an unaligned address generates an Alignment fault. Memory accesses generated by Load-Acquire pair or Store-Release pair instructions must be aligned to the size of the pair, otherwise the access generates an Alignment fault.

$\triangle$ A Store-Release Exclusive instruction has the Release semantics only if the store is successful.

$\triangle$ FEAT_LRCPC2 introduces changes to the alignment requirements of Load-Acquire/Store-Release instructions.

###### Table C3-23 Non-exclusive Load-Acquire and Store-Release instructions

$\triangle$ `LDAPR`, `LDAPRB`, `LDAPRH`, `LDAPUR`, `LDAPURB`, `LDAPURH`, `LDAPURSB`, `LDAPURSH`, `LDAPURSW`, `LDAR`, `LDARB`, `LDARH`, `STLR`, `STLRB`, `STLRH`, `STLUR`, `STLURB`, `STLURH`. 

###### Table C3-24 Exclusive Load-Acquire and Store-Release instructions

$\triangle$ `LDAXR`, `LDAXRB`, `LDAXRH`, `LDAXP`, `STLXR`, `STLXRB`, `STLXRH`, `STLXP`.

### C3.2.8 LoadLOAcquire/StoreLORelease

$\triangle$ The LoadLOAcquire/StoreLORelease instructions support only one addressing mode: Base register with no offset.

$\triangle$ The LoadLOAcquires/StoreLORelease instructions can remove the requirement to use the explicit DMB memory barrier instruction. 

$\triangle$ The LoadLOAcquire/StoreLORelease instructions require natural alignment, and an unaligned address generates an Align fault.

###### Table C3-25 LoadLOAcquire and StoreLORelease instructions

$\triangle$ `LDLARB`, `LDLARH`, `LDLAR`, `STLLRB`, `STLLRH`, `STLLR`.

### C3.2.9 Load/store scalar SIMD and floating-point

$\triangle$ The load/store scalar SIMD and floating-point instructions operate on scalar values in the SIMD and floating-point register file. The memory addressing modes available are identical to the general-purpose register load/store instructions, and like those instructions permit arbitrary address alignment unless strict alignment checking is enabled. However, unlike the load/store instructions that transfer general-purpose registers, load/store scalar SIMD and floating-point instructions make no guarantee of atomicity, even when the address is naturally aligned to the size of the data.

#### Load/store scalar SIMD and floating-point register

$\triangle$ The load/store scalar SIMD and floating-point register instructions support the following addressing modes:
- Base plus a scaled 12-bit unsigned immediate offset or base plus unscaled 9-bit signed immediate offset.
- Base plus 64-bit register offset, optionally scaled.
- Base plus 32-bit extended register offset, optionally scaled.
- Pre-indexed by an unscaled-9bit signed immediate offset.
- Post-indexed by an unscaled-9bit signed immediate offset.
- PC-relative literal for loads of 32 bits or more.

$\triangle$  The unscaled 9-bit signed immediate offset address mode requires its own instruction form.

###### Table C3-26 Load/store single SIMD and floating-point register instructions

$\triangle$ `LDR`, `STR`.

#### Load/store scalar SIMD and floating-point register (unscaled offset)

$\triangle$ The load/store scalar SIMD and floating-point register instructions support only one addressing mode: Base plus an unscaled 9-bit signed immediate offset.

$\triangle$ The load/store scalar SIMD and floating-point register (unscaled offset) instructions are required to disambiguate this instruction class from the load/store single SIMD and floating-point instruction forms that support an addressing mode of base plus a scaled, unsigned 12-bit immediate offset. The is similar to the load/store register (unscaled offset) instructions, that disambiguate this instruction class from the load/store register instruction.

###### Table C3-27 Load/store SIMD and floating-point register instructions

$\triangle$ `LDUR`, `STUR`.

#### Load/store SIMD and floating-point register pair

$\triangle$ The load/store SIMD and floating-point register pair instructions support the following addressing modes:
- Base plus a scaled 7-bit signed immediate offset.
- Pre-indexed by a scaled 7-bit signed immediate offset.
- Post-indexed by a scaled 7-bit signed immediate offset.

$\triangle$ If a Load pair instruction specifies the same register for the two registers that are being loaded, then behavior is CONSTRAINED UNPREDICTABLE and one the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all of the loads using the specified addressing mode and the register being loaded takes an UNKNOWN value.

###### Table C3-28 Load/store SIMD and floating-point register pair instructions

$\triangle$ `LDP`, `STP`.

#### Load/store SIMD and floating-point non-temporal pair

$\triangle$ The load/store SIMD and floating-point non-temporal pair instructions support only one addressing mode: Base plus a scaled 7-bit signed immediate offset.

$\triangle$ The load/store non-temporal pair instructions provide a hint to the memory system that an access is non-temporal or streaming, and unlikely to be repeated in the near feature. This means that data caching is not required. However, depending on the memory type, the instructions might permit memory reads to be preloaded and memory writes to be gathered to accelerate bulk memory transfers.

$\triangle$ In addition, there is an exception to the usual memory ordering rules. If an address dependency exists between two memory reads, and a load non-temporal pair instruction generated the second read, then in the absence of any other barrier mechanism to achieve order, those memory access can be observed in any order by the other observers within the shareability domain of the memory addresses being accessed.

$\triangle$ If a load non-temporal pair instruction specifies the same register for the two registers that are being loaded, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all the loads using the specified addressing mode and the register that is loaded takes an UNKNOWN value.

###### Table C3-29 Load/store SIMD and floating-point non-temporal pair instructions

$\triangle$ `LDNP`, `STNP`.

### C3.2.10 Load/store Advanced SIMD

$\triangle$ The Advanced SIMD load/store structure instructions support the following addressing mode:
- Base register only.
- Post-indexed by a 64-bit register.
- Post-indexed by an immediate, equal to the number of bytes transferred.

$\triangle$ Load/store vector instructions, like other load/store instructions, allow any address alignment, unless strict alignment checking is enabled. If strict alignment checking is enabled, then alignment checking to the size of the element is performed. However, unlike the load/store instructions that transfer general-purpose registers, the load/store vector instructions do not guarantee atomicity, even when the address is naturally aligned to the size of the element.

#### Load/store structures

$\triangle$ A post-increment immediate offset, if present, must be 8, 16, 24, 32, 48, or 64, depending on the number of elements transferred.

###### Table C3-30 Load/store multiple structures instructions

$\triangle$ `LD1`, `LD2`, `LD3`, `LD4`, `ST1`, `ST2`, `ST3`, `ST4`.

#### Load single structure and replicate

$\triangle$ A post-increment immediate offset, if present, must be 1, 2, 3, 4, 6, 8, 12, 16, 24, or 32, depending on the number of elements transferred.

###### Table C3-31 Load single structure and replicate instructions

$\triangle$ `LD1R`, `LD2R`, `LD3R`, `LD4R`.

### C3.2.11 Prefetch memory

$\triangle$ The Prefetch memory instructions support the following addressing modes:
- Base plus a scaled 12-bit unsigned immediate offset or base plus an unscaled 9-bit signed immediate offset.
- Base plus a 64-bit register offset. This can be optionally scaled by 8-bits.
- Base plus a 32-bit extended register offset. This can be optionally scaled by 8-bits
- PC-relative literal.

$\triangle$ The prefetch memory instructions signal to the memory system that memory accesses from a specified address are likely to occur in the near future. The memory system can respond by talking actions that are expected to speed up the memory access when they do occur, such as preloading the specified address into one or more caches. Because these signals are only hints, it is valid for the PE to treat any or all prefetch instructions as a `NOP`.

$\triangle$ Because they are hints to the memory system, the operation of a `PRFM` instruction cannot cause a synchronous exception. However, a memory operation performed as a result of one of these memory system hints might in exceptional cases trigger an asynchronous event, and thereby influence the execution of the PE. An example of an asynchronous event that might be triggered is an SError interrupt.

$\triangle$ A `PRFM` instruction can only have an effect on software visible structures, such as caches and translation lookaside buffers associated with memory locations that can be accessed by reads, writes or execution as defined in the translation regime of the current Exception level.

$\triangle$ A `PRFM` instruction is guaranteed not to access Device memory.

$\triangle$ A `PRFM` instruction using a `PLI` hint must not result in any access that could not be performed by the PE speculatively fetching an instruction. Therefore, if all associated MMUs are disabled, a `PLI` hint cannot access any memory location that cannot be accessed by instruction fetches.

$\triangle$ The `PRFM` instructions require an additional `<prfop>` operand to be specified, which must be one of the following: `PLDL1KEEP`, `PLDL1STRM`, `PLDL2KEEP`, `PLDL2STRM`, `PLDL3KEEP`, `PLDL3STRM`, `PSTL1KEEP`, `PSTL1STRM`, `PSTL2KEEP`, `PSTL2STRM`, `PSTL3KEEP`, `PSTL3STRM`, `PLIL1KEEP`, `PLIL1STRM`, `PLIL2KEEP`, `PLIL2STRM`, `PLIL3KEEP`, `PLIL3STRM`.

$\triangle$ `<prfop>` is defined as \<type\>\<target\>\<policy\>.
- \<type\> is one of `PLD` (Prefetch for load), `PST` (Prefetch for store), `PLI` (Preload instructions).
- \<target\> is one of `L1` (Level 1 cache), `L2` (Level 2 cache), `L3` (Level 3 cache).
- \<policy> is one of `KEEP` (Retained or temporal prefetch, allocated in the cache normally), `STRM` (Streaming or non-temporal prefetch, for data that is used only once).

$\triangle$ `PRFUM` explicitly uses the unscaled-9bit signed immediate offset addressing mode.

###### Table C3-32 Prefetch memory instructions

$\triangle$ `PRFM`, `PFRUM`

### C3.2.12 Atomic instructions

$\triangle$ The atomic instructions perform atomic read and write operations on a memory location such that the architecture guarantees that no modification of that memory location by another observer can occur between the read and the write defined by that instruction.

#### Atomic memory operations

$\triangle$ The atomic memory operation instructions support only one addressing mode: Base register only.

$\triangle$ For the purpose of permission checking, and for watchpoints, all of the Atomic memory operation instructions are treated as performing both a load and a store.

$\triangle$ If FEAT_LES2 is not implemented that the `LD<OP>` and `ST<OP>` instructions require natural alignment, and an unaligned address generates an Alignment fault.

$\triangle$ The instructions are provided with ordering options, which map to the acquire and release definitions used in the architecture. The atomic instructions with release semantics have the same rules as Store-Release instructions regarding multi-copy atomicity. These operations map to the acquire and release definitions, and are counted as Load-Acquire and Store-Release operations respectively.

$\triangle$ For the `LD<OP>` instructions, where the source and destination registers are the same, if the instruction generates a synchronous Data Abort, then the source register is restored to the value it held before the instruction was executed.

$\triangle$ The `ST<OP>` instructions, and `LD<OP>` instructions where the destination register is WZR or XZR, are not regarded as doing a read for the purpose of a `DMB LD` barrier.

###### Table C3-33 Atomic memory operation instructions

$\triangle$ `LDADD`, `LDADDB`, `LDADDH`, `LDCLR`, `LDCLRB`, `LDCLRH`, `LDEOR`, `LDEORB`, `LDEORH`, `LDSET`, `LDSETB`, `LDSETH`, `LDMAX`, `LDMAXB`, `LDMAXH`, `LDMIN`, `LDMINB`, `LDMINH`, `LDUMAX`, `LDUMAXB`, `LDUMAXH`, `LDUMIN`, `LDUMINB`, `LDUMINH`, `STADD`, `STADDB`, `STADDH`, `STCLR`, `STCLRB`, `STCLRH`, `STEOR`, `STEORB`, `STEORH`, `STSET`, `STSETB`, `STSETH`, `STMAX`, `STMAXB`, `STMAXH`, `STMIN`, `STMINB`, `STMINH`, `STUMAX`, `STUMAXB`, `STUMAXH`, `STUMIN`, `STUMINB`, `STUMINH`.

#### Single-copy atomic 64-byte load/store

$\triangle$ If FEAT_LS64 is implemented, the following instructions are implemented: LD64B, ST64B.

$\triangle$ If FEAT_LS64_V is implemented, the following instructions are implemented: LD64B, ST64B, ST64BV. 

$\triangle$ if FEAT_LS64_ACCDATA is implemented, the following instructions are implemented: LD64B. ST64B, ST64BV, ST64BV0.

$\triangle$ The single-copy atomic 64-byte load/store instructions support one addressing mode: Base register only.

$\triangle$ The memory location accessed by the instruction is required to be aligned on a 64-byte boundary, otherwise an Alignment fault occurs.

$\triangle$ When the instructions access a memory type that is not one of the following, a data abort for unsupported Exclusive or atomic access is generated for the stage of translation that provided the memory type:
- Normal Inner Non-cacheable, Outer Non-cacheable.
- Device-GRE.
- Device-nGRE.
- Device-nGnRE.
- Device-nGnRnE.

$\triangle$ Regardless of the memory type:
- The memory access generated by an ST64BV or ST64BV0 instruction is not merged with any access.
- The memory access generated by an ST64B instruction is not merged with any accesses generated by store instructions appearing in program order after this instruction.

###### Table C3-34 Single-copy atomic 64-byte load/store instructions

$\triangle$ `LD64B`, `ST64B`.

###### Table C3-35 Single-copy atomic 64-byte store with return instructions

$\triangle$ `ST64BV`.

###### Table C3-36 Single-copy atomic 64-byte EL0 store with return instructions

$\triangle$ `ST64BV0`.

#### Swap

$\triangle$ The swap instructions support only one addressing mode: Base register only.

$\triangle$ For the purpose of permission checking, and for watchpoints, all of the Swap instructions are treated as performing both a load and a store.

$\triangle$ If FEAT_LSE2 is not implemented, then the SWP instructions require natural alignment, and an unaligned address generates an Alignment fault. 

$\triangle$ The instructions are provided with ordering options, which map to the acquire and release definitions used in the architecture. The atomic instructions with release semantics have the same rules as Store-Release instructions regarding multi-copy atomicity.

$\triangle$ For the `SWP` instructions, where the source and destination registers are the same, if the instruction generates a synchronous Data Abort, then the source register is restored to the value it held before the instruction as executed.

###### Table C3-37 Swap instructions

$\triangle$ `SWP`, `SWPB`, `SWPH`.

#### Compare and Swap

$\triangle$ The Compare and Swap instructions support only one addressing mode: Base register only.

$\triangle$ For the purpose of permission checking, and for watchpoints, all of the Compare and Swap instructions are treated as performing both a load and store.

$\triangle$ If FEAT_LSE2 is not implemented then:
- The `CAS` instructions require natural alignment.
- THe `CASP` instructions require alignment to the total size of the memory being accessed.

$\triangle$ The instructions are provided with ordering options, which map to the acquire and release definitions used in the architecture. If a compare and swap instruction does not perform a store, then the instruction does not have release semantics, regardless of the instruction ordering options.

$\triangle$ The atomic instructions with release semantics have the same rules as Store-Release instructions regarding multi-copy atomicity.

$\triangle$ For the `CAS` and `CASP` instructions, the architecture permits that a data read clears any Exclusives monitors associated with that location, even if the compare subsequently fails. If these instructions generate a synchronous Data Abort, the registers which are compared and loaded are restored to the values held in the registers before the instruction was executed.

###### Table C3-38 Compare and swap instructions

### C3.2.13 Memory Tagging instructions

###### Table C3-39 Tag generation instructions

$\triangle$ `ADDG`, `GMI`, `IRG`, `SUBG`.

###### Table C3-40 Pointer Arithmetic

$\triangle$ `SUBP(S)`.

###### Table C3-41 Tag setting instructions

$\triangle$ `STG`, `STZG`, `ST2G`, `STZ2G`, `STGP`.

###### Table C3-42 Tag getting instructions

$\triangle$ `LDG`.

###### Table C3-43 Bulk Allocation Tag access

$\triangle$ `LDGM`, `STGM`, `STZGM`.

### C3.2.14 Memory Copy and Memory Set instructions

$\triangle$ If FEAT_MOPS is implemented, the `CPY*`, `SETE*`, `SETM*`, and `SETP*` instructions described in this section are implemented. If FEAT_MOPS and FEAT_MTE are implemented, the `SETG*` instructions described in this section are also implemented. Collectively, the instructions described in this section are referred to as *Memory Copy and Memory Set* instructions.

$\triangle$ To perform a memory copy or memory set, three instructions - a prologue, then a main, and then an epilogue - are expected to be run in succession, with no instruction appearing in the code between them:
- To perform a memory copy, forward-only: `CPYFP*`, then `CPYFM*`, and then `CPYFE*`.
- To perform a memory copy, forward or backward: `CPYP*`, then `CPYM*`, and then `CPYE*`.
- To perform a memory set with tag setting: `SETGP*`, then `SETGM*`, and then `SETGE*`.
- To perform a memory set without tag setting: `SETP*`, then `SETM*`, and then `SETE*`.

$\triangle$ The variant of each instruction is also expected to be the same throughout one of these sequences. For example,
`CPYFPWTWN`, `CPYFMWTWN`, `CPYFEWTWN`.

$\triangle$ Fetching of a Memory Copy and Memory Set instruction multiple times during its execution is permissible.

$\triangle$ Memory Copy and Memory Set exceptions can be generated by execution of Memory Copy and Memory Set instructions restarting on a physical hardware PE implementation that is different from the physical hardware PE implementation that an exception was taken from. 

$\triangle$ If an exception is taken during the execution of a Memory Copy and Memory Set instruction, that instruction has not been executed for the purposes of instruction counting, instruction tracing, statistical profiling, or single stepping.

$\triangle$ For the purposes of single stepping and performance monitoring, each Memory Copy and Memory Set instruction is regarded as a single instruction that performs a store and, in the case of `CPY*` instructions, also performs a load.

$\triangle$ For Memory Copy and Memory Set instructions, the following are not architecturally defined:
- The size of the memory transactions they create.
- The order between accesses to different addresses.

$\triangle$ The `CPY*` instructions are guaranteed to make forward progress if none of the following four leaf level translation table entries fault:
- The source leaf level translation table entry held in Xs.
- The next leaf level translation table entry, as determined by the copy direction, adjacent to the source leaf level translation table entry held in Xs.
- The destination leaf level translation table entry held in Xd.
- The next leaf level translation table entry, as determined by the copy direction, adjacent to the destination leaf level translation table entry held in Xd.

$\triangle$ The `SET*` instructions are guaranteed to make forward progress if neither of the following two leaf level translation table entries fault:
- The destination leaf level translation table entry held in Xd.
- The next leaf level translation table entry adjacent to the destination leaf level translation table entry held in Xd.

$\triangle$ The forward progress described in this section can be achieved by ensuring that, when a memory management fault is encountered, all bytes leading up to the fault have been operated on.

###### Table C3-44 Memory copy, forward-only instructions

$\triangle$ `CPYFE`, `CPYFEN`, `CPYFERN`, `CPYFERT`, `CPYFERTN`, `CPYFERTRN`, `CPYFERTWN`, `CPYFET`, `CPYFETN`, `CPYFETRN`, `CPYFETWN`, `CPYFEWN`, `CPYFEWT`, `CPYFEWTN`, `CPYFEWTRN`, `CPYFMWTWN`, `CPYFM`, `CPYFMN`, `CPYFMRN`, `CPYFMRT`, `CPYFMRTN`, `CPYFMRTRN`, `CPYFMRTWN`, `CPYFMT`, `CPYFMTN`, `CPYFMTRN`, `CPYFMTWN`, `CPYFMWN`, `CPYFMWT`, `CPYFMWTN`, `CPYFMWTRN`, `CPYFMWTWN`, `CPYFP`, `CPYFPN`, `CPYFPRN`, `CPYFPRT`, `CPYFPRTN`, `CPYFPRTRN`, `CPYFPRTWN`, `CPYFPT`, `CPYFPTN`, `CPYFPTRN`, `CPYFPTWN`, `CPYFPWN`, `CPYFPWT`, `CPYFPWTN`, `CPYFPWTRN`

###### Table C3-45 Memory copy, forward or backward instructions

$\triangle$ `CPYE`, `CPYEN`, `CPYERN`, `CPYERT`, `CPYERTN`, `CPYERTRN`, `CPYERTWN`, `CPYET`, `CPYETN`, `CPYETRN`, `CPYETWN`, `CPYEWN`, `CPYEWT`, `CPYEWTN`, `CPYEWTRN`, `CPYMWTWN`, `CPYM`, `CPYMN`, `CPYMRN`, `CPYMRT`, `CPYMRTN`, `CPYMRTRN`, `CPYMRTWN`, `CPYMT`, `CPYMTN`, `CPYMTRN`, `CPYMTWN`, `CPYMWN`, `CPYMWT`, `CPYMWTN`, `CPYMWTRN`, `CPYMWTWN`, `CPYP`, `CPYPN`, `CPYPRN`, `CPYPRT`, `CPYPRTN`, `CPYPRTRN`, `CPYPRTWN`, `CPYPT`, `CPYPTN`, `CPYPTRN`, `CPYPTWN`, `CPYPWN`, `CPYPWT`, `CPYPWTN`, `CPYPWTRN`, `CPYPWTWN`.

###### Table C3-46 Memory set with tag setting instructions

$\triangle$ `SETGE`, `SETGEN`, `SETGET`, `SETGETN`, `SETGM`, `SETGMN`, `SETGMT`, `SETGMTN`, `SETGP`, `SETGPN`, `SETGPT`, `SETGPTN`.

###### Table C3-47 Memory set without tag setting instructions

$\triangle$ `SETE`, `SETEN`, `SETET`, `SETETN`, `SETM`, `SETMN`, `SETMT`, `SETMTN`, `SETP`, `SETPN`, `SETPT`, `SETPTN`.

## C3.3 Loads and stores - SVE

$\triangle$ SVE vector load ans store instructions transfer data in memory to or from elements of one or more vector or predicate transfer registers. SVE also includes vector prefetch instructions that provide read and write hints to the memory system. For SVE predicated load, store, and prefetch instructions, the memory element access size and type that is associated with each vector element is specified by a suffix to the instruction mnemonic, independently of the element size of the transfer registers. 

$\triangle$ The element size of the transfer registers is always greater than or equal to the memory element access size. When the element size of the transfer registers is strictly greater than the memory element access size, then these are referred to as unpacked data accesses. In the case of unpacked data accesses:
- For load instructions, each element access is sign-extended or zero-extended to fill the vector element, according to its memory element access size and type.
- For store instructions, each vector elements is truncated to the memory element access size.

$\triangle$ Where the vector element size and the memory element access size are the same, then these are referred to as packed data accesses. Signed access types are not supported for packed data accesses. Packed and unpacked access sizes and types relate to the vector element size of the transfer registers.

$\triangle$ For gather-load and scatter-store instructions, the vector element size can only be .S or .D. This means that any non-contiguous memory element access of less than a word is unpacked. Non-contiguous memory element accesses of a word can be either packed or unpacked, depending on the vector element size.

$\triangle$ All predicated load instructions zero the *Inactive elements* of the destination vector, except for Non-fault loads and First-fault loads when the corresponding FFR element is FALSE.

$\triangle$ Prefetch instructions provide hints to hardware and do not change architectural state. Therefore, a *Governing predicate* for a prefetch instruction provides an additional hint which indicates the memory locations to be prefetched. Prefetch instructions require a prefetch operation specifier. SVE prefetch instruction support all of the prefetch operations except for the PLI prefetch operand types.

$\triangle$ Load, store, and prefetch instructions that multiply a scalar index register or an index vector element by the memory element access size specify a sift type, followed by a shift amount in bits. The shift type can be one of `LSL`, `SXTW`, or `UXTW`. The shift amount is always Log~2~ of the memory element access size, in bytes. The shift amount defaults to zero when the memory element access size is a byte, and the shift size can be omitted. The shift type of `LSL` must be omitted if the shift amount is omitted.

$\triangle$ When included as part of the assembler syntax for an instruction, `MUL VL` indicates that the specified immediate index value is multiplied by the size of the addressed vector or predicate in memory, measured in bytes, irrespective of predication. FOr a detailed description of the meaning of this assembler syntax for each instruction. When used in pseudocode, the symbol `VL` represents the vector length, measured in bits.

$\triangle$ SVE load, store and prefetch instructions do not support pre-indexed or post-indexed addressing.

### C3.3.1 Predicated single vector contiguous element accesses

$\triangle$ Predicated contiguous load and store instructions access memory locations starting from an address that is defined by a scalar base register plus either:
- A scalar index register.
- An immediate index value that is in the range -8 to 7, inclusive. This defaults to zero is omitted.

$\triangle$ The predicated contiguous load and store instructions have two supporting addressing modes:
- Scalar base plus immediate index.
- Scalar base plus scalar index.

$\triangle$ Predicated contiguous prefetch instructions address memory locations in a similar manner, with the index being either:
- A scalar index register.
- An immediate index value that is in the range of -32 to 31, inclusive. This defaults to zero if omitted.

$\triangle$ For predicated contiguous load and store SVE instructions:
- The immediate index value is a vector index, not an element index. The immediate index value is multiplied by the number of vector elements, irrespective of predication, and then multiplied by the memory element access size in bytes. The result offset is incremented following each element access by the memory element access size.
- The scalar index register value is multiplied by the memory element access size in bytes. The index value is incremented by one after each element access, but the scalar index register is not updated by the instruction.
- When alignment checking is enabled for loads and stores, the value of the base address register must be aligned to the memory element access size.

###### Table C3-48 Predicated single vector contiguous element accesses

$\triangle$ `LD1`, `ST1`, `LDFF1`, `LDNF1`, `LDNT1`, `STNT1`, `PRF`.

### C3.3.2 Predicated multiple vector contiguous structure load/store

$\triangle$ Predicated multiple vector contiguous structure load/store instructions are defined by a scalar base register plus either:
- A scalar index register.
- An immediate index that is a multiple of N, in the range -8xN to 7xN, inclusive. This default to zero if omitted.

$\triangle$ The predicated contiguous structure load and store instructions have two supporting addressing modes:
- Scalar base plus immediate index.
- Scalar base plus scalar index.

$\triangle$ For the predicated multiple vector contiguous structure load/store SVE instructions:
- The immediate index value is a vector index, not an element index. The immediate index value is multiplied by the number of vector elements, irrespective of predication, and then multiplied by the memory element access size in bytes. The resulting offset is incremented following each element access by the memory element access size.
- The scalar index register value is multiplied by the memory element access size in bytes. Following each element access, the index value is incremented by one but the instruction does not update the scalar index register.
- Each predicate element applies to a single structure in memory, or equivalently to the same element number within each of the two, three, or four transferred vector registers.
- These instructions support packed data accesses only.
- When alignment checking is enabled for loads and stores, the base address must be aligned to the element access size.

###### Table C3-49 Predicated multiple vector contiguous structure load/store

$\triangle$ `LD2`, `LD3`, `LD4`, `ST2`, `ST3`, `ST4`.

### C3.3.3 Predicated non-contiguous element access

$\triangle$ Predicated non-contiguous element accesses address non-contiguous memory locations that are specified by either:
- A scalar base register plus a vector of indices or offsets.
- A vector of base addresses plus an immediate byte offset. The immediate byte offset is a multiple of the memory element access size, in the range 0 to 31 times the memory element access size, inclusive, and defaults to zero if omitted.

$\triangle$ The predicated non-contiguous element accesses have two supporting addressing modes:
- Scalar base plus 64-bit vector index.
- Scalar base plus 32-bit vector index.
- Vector base plus immediate offset.

$\triangle$ For this group of SVE instructions:
- Vector registers used as part of the address must specify a vector element size of 32 bits or 64 bits, .S or .D. For load and store instructions, the transfer register must specify the same vector element size.
- If the index vector register contains 32-bit index values then the lowest 32 bits of each index vector element can either be zero-extended or sign-extended to 64 bits.
- For load and store instructions, the index vector elements are then optionally multiplied by the memory element access size, in bytes, if a shift amount is specified. For prefetch instructions, the index vector elements are always multiplied by the memory element access size, in bytes.
- When alignment checking is enabled for loads and stores, the computed virtual address of each element must be aligned to the memory element access size.

###### Table C3-50 Predicated non-contiguous element accesses

$\triangle$ `LD1`, `ST1`, `LDFF1`, `PRF`.

### C3.3.4  Predicated replicating element loads

$\triangle$ The load and replicate instructions read one or more contiguous memory locations starting from an address that is defined by a scalar base register plus either:
- A scalar index register.
- An immediate byte offset.

$\triangle$ The predicated contiguous load and store instructions have two supporting addressing modes:
- Scalar base plus immediate offset.
- Scalar base plus scalar index.

$\triangle$ This defaults to zero if omitted. For predicated replicating element load SVE instructions:
- When alignment checking is enabled, the base address must be aligned to the memory element access size.

###### Table C3-51 Predicated replicating element loads

$\triangle$ `LD1RB`, `LD1RD`, `LD1RH`, `LD1RW`, `LD1RQB`, `LD1RQD`, `LD1RQH`, `LD1RQW`.

### C3.3.5 Unpredicated vector register load/store

$\triangle$ The unpredicated vector register load, LDR, and store, STR, instructions transfer a single vector register from or to memory locations that are specified by a scalar base register plus an immediate index value that is in the range -256 to 255, inclusive. The immediate index value defaults to zero if omitted.

$\triangle$ The unpredicated vector register load/store instructions have one supporting addressing mode:
- Scalar base plus immediate index.

$\triangle$ For the unpredicated vector register load/store SVE instructions:
- The immediate index value is a vector index, not an element index. The immediate index value is multiplied by the current vector register length in bytes.
- The data transfer is performed as a contiguous stream of byte accesses in ascending element order, without endianness conversion.
- When alignment checking is enabled for loads and stores, the base address must be 16-byte aligned.

###### Table C3-52 Unpredicated vector register load/store

$\triangle$ `LDR`, `STR`.

### C3.3.6 Unpredicated predicate register load/store

$\triangle$ The unpredicated predicate register load, LDR, and store, STR, instructions transfer a single predicate register from or to memory locations that are specified by a scalar base register plus an immediate index value that is in the range -256 to 255, inclusive. The immediate index value defaults to zero if omitted.

$\triangle$ The unpredicated predicate register load/store instructions have one supporting addressing mode:
- Scalar base plus immediate index.

$\triangle$ For unpredicated predicate register load/store SVE instructions:
- The immediate index value is a predicate index, not an element index. The immediate index value is multiplied by the current predicate register length, in bytes.
- The data transfer is performed as a contiguous stream of byte accesses, each byte containing 8 consecutive predicate bits, in ascending bit and element order, without endian conversion.
- When alignment checking is enabled for loads and stores, the base address must be 2-byte aligned.

###### Table C3-52 Unpredicated predicate register load/store

$\triangle$ `LDR`, `STR`.
