# Chapter C3 A64 Instruction Set Overview

## C3.1 Branches, Exception generating, and System Instructions

$\triangle$ Software must:
- Use only `BLR` or `BL` to perform a nested subroutine call when the subroutine is expected to return to the immediately following instruction, that is the instruction with the address of the `BLR` or `BL` instruction incremented by four.
- Use only `RET` to perform a subroutine return, when the subroutine is expected to have been entered by a `BL` or `BLR` instruction.
- Use only `B`, `BR` or the instruction listed in Table C3-1 to perform a control transfer that is not a subroutine call or subroutine return described in this Note.

### C3.1.1 Conditional branch

$\triangle$ Conditional branches change the flow of execution depending on the current state of the Condition flags or the value in a general-purpose register.

###### Table C3-1 Conditional branch instructions

$\triangle$ `B.cond`, `BC.cond`, `CBNZ`, `CBZ`, `TBNZ`, `TBZ`.

### C3.1.2 Unconditional branch (immediate)

$\triangle$ Unconditional branch (immediate) instructions change the flow of execution unconditionally by adding an immediate offset with a range of $\pm$ 128MB to the value of the program counter that fetched the instruction. The `BL` instruction also writes the address of the sequentially following instruction to general-purpose register X30.

###### Table C3-2 Unconditional branch instructions (immediate)

$\triangle$ `B`, `BL`.

### C3.1.3 Unconditional branch (register)

$\triangle$ Unconditional branch (register) instructions change the flow of execution unconditionally by setting the program counter to the value in a general-purpose register. The `BLR` instruction also writes the address of the sequentially following instruction to a general-purpose register X30. THe `RET` instruction behaves identically to `BR`, but provides an additional hint to the PE that this is a return from subroutine.

###### Table C3-3 Unconditional branch instructions (register)

$\triangle$ `BLR`, `BR`, `RET`.

### C3.1.4 Exception generation and return.

#### Exception generating

###### Table C3-4 Exception generation instruction

$\triangle$ `BRK`, `HLT`, `HVC`, `SMC`, `SVC`.

#### Exception return

###### Table C3-5 Exception return instruction

$\triangle$ `ERET`.

#### Debug state

###### Table C3-6 Debug state instructions

$\triangle$ `DCPS1`, `DCPS2`, `DCPS3`, `DRPS`.

### C3.1.5 System register instructions

###### Table C3-7 System register instructions

$\triangle$ `MRS`, `MSR`.

### C3.1.6 Instructions with register argument

###### Table C3-8 Instructions with register argument

$\triangle$ `WFET`, `WFIT`.

### C3.1.7 System Instructions

###### Table C3-9 System instructions

$\triangle$ `SYS`, `SYSL`, `IC`, `DC`, `AT`, `TLBI`.

### C3.1.8 Hint Instructions

###### Table C3-10 Hint instructions

$\triangle$ `NOP`, `YIELD`, `WFE`, `WFI`, `SEV`, `SEVL`, `HINT`, `DGH`.

### C3.1.9 Barriers and CLREX instructions

###### Table C3-11 Barriers and CLREX instructions.

$\triangle$ `CLREX`, `DMB`, `DSB`, `ISB`.

###### Table C3-12 Speculation and synchronization barriers

$\triangle$ `CSDB`, `ESB`, `PSB CSYNC`, `PSSBB`, `SB`, `SSBB`, `TSB CYNC`.

### C3.1.10 Pointer authentication instructions

#### Basic pointer authentication instructions

$\triangle$ Each of these instructions only performs an operation that supports pointer authentication.

###### Table C3-13 Instructions that add a PAC

$\triangle$ `PACIASP`, `PACIAZ`, `PACIA1716`, `PACIBSP`, `PACIBZ`, `PACIB1716`, `PACIA`, `PACDA`, `PACIB`, `PACDB`, `PACIZA`, `PACDZA`, `PACIZB`, `PACDZB`, `PACGA`.

###### Table C3-14 Instructions that authenticate a PAC

$\triangle$ `AUTIASP`, `AUTIAZ`, `AUTIA1716`, `AUTIBSP`, `AUTIBZ`, `AUTIB1716`, `AUTIA`, `AUTDA`, `AUTIB`, `AUTDB`, `AUTIZA`, `AUTDZA`, `AUTIZB`, `AUTDZB`.

###### Table C3-15 Instructions that strip a PAC

$\triangle$ `XPACLRI`, `XPACI`, `XPACD`.

#### Combined instructions that include pointer authentication

$\triangle$ Each of these instructions combines a pointer authentication with another operation that use the authenticated pointer.

###### Table C3-16 Combined pointer authentication instructions

$\triangle$ `RETAA`, `RETAB`, `BRAA`, `BRAB`, `BLRAA`, `BLRAB`, `BRAAZ`, `BRABZ`, `BLRAAZ`, `BLRABZ`, `ERETAA`, `ERETAB`, `LDRAA`, `LDRAB`.

## C3.2 Loads and stores

$\triangle$ The requirements for the alignment of data memory accesses are strict.

$\triangle$ The additional control bits SCTLR_ELx.SA and SCTLR_EL1.SA0 control whether the stack pointer must be quadword aligned when used as a base register. Using a misaligned stack pointer generates an SP alignment fault exception.

$\triangle$ In some cases, load/store instructions can lead to CONSTRAINED UNPREDICTABLE behavior.

### C3.2.1 Load/store register

$\triangle$ The load/store register instructions support the following addressing modes:
- Base plus a scaled 12-bit unsigned immediate offset or base plus an unscaled 9-bit signed immediate offset.
- Base plus a 64-bit register offset, optionally scaled.
- Base plus a 32-bit extended register offset, optionally scaled.
- Pre-indexed by an unscaled 9-bit signed immediate offset.
- Post-indexed by an unscaled 9-bit signed immediate offset.
- PC-relative literal for loads of 32b bits or more.

$\triangle$ If a Load instruction specifies writeback and the register being loaded is also the base register, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs the load using the specified addressing mode and the base register becomes UNKNOWN. In addition, if an exception occurs during the execution of such an instruction, the base address might be corrupted so that the instruction cannot be repeated.

$\triangle$ If a Store instruction performs a writeback and the register that is stored is also the base register, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs the store to the designated register using the specified addressing mode, but the value stored is UNKNOWN.

> NOTE: 这样定义的原因是什么？有点奇怪。

###### Table C3-17 Load/store register instructions

$\triangle$ `LDR`, `LDRB`, `LDRSB`, `LDRH`, `LDRSH`, `LDRSW`, `STR`, `STRB`, `STRH`.

### C3.2.2 Load/store register (unscaled offset)

$\triangle$ The load/store register instructions with an unscaled offset support only one addressing mode: Base plus an unscaled 9-bit signed immediate offset.

$\triangle$ The load/store register (unscaled offset) instructions are required to disambiguate this instruction class from the load/store register instruction forms that support an addressing mode of base plus a scaled, unsigned 12-bit immediate offset, because that can represent some offset values in the same range.

$\triangle$ The ambiguous immediate offsets are byte offsets that are both:
- In the range 0-255, inclusive.
- Naturally aligned to the access size.

$\triangle$ Other byte offsets in the range -256 to 255 inclusive are unambiguous, An assembler program translating a load/store instruction. Arm recommends that a disassembler outputs all unscaled 9-bit offset forms using one of these mnemonics, but unambiguous offsets can be output using a load/store single register mnemonic, for example, `LDR`.

###### Table C3-18 Load/store register (unscaled offset) instructions

$\triangle$ `LDUR`, `LDURB`, `LDURSB`, `LDURH`, `LDURSH`, `LDURSW`, `STUR`, `STURB`, `STURH`.

### C3.2.3 Load/store pair

$\triangle$ The load/store pair instructions support the following addressing modes:
- Base plus a scaled 7-bit signed immediate offset.
- Pre-indexed by scaled 7-bit signed immediate offset.
- Post-indexed by scaled 7-bit signed immediate offset.

$\triangle$ If a Load Pair instruction specifies the same register for the two registers that are being loaded, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all the loads using the specified addressing mode and the register that is loaded takes an UNKNOWN value.

$\triangle$ If a Load Pair instruction specifies writeback and one of the registers being loaded is also the base register, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all of the loads using the specified addressing mode, and the base register becomes UNKNOWN. In addition, if an exception occurs during the instruction, the base address might be corrupted so that the instruction cannot be repeated.

$\triangle$ If a Store Pair instruction performs a writeback and one of the registers being stored is also the base register, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all the stores of the registers indicated by the specified addressing mode, but the value stored for the base register is UNKNOWN.

###### Table C3-19 Load/store pair instructions

$\triangle$ `LDP`, `LDPSW`, `STP`.

### C3.2.4 Load/store non-temporal pair

$\triangle$ The load/store non-temporal pair instruction support only one address mode: Base plus a scaled 7-bit signed immediate offset.

$\triangle$ The load/store non-temporal pair instructions provide a hint to the memory system that an access is non-temporal or streaming, and unlikely to be repeated in the near feature. This means that data caching is not required. However, depending on the memory type, the instructions might permit memory reads to be preloaded and memory writes to be gathered to accelerate bulk memory transfers. 

> NOTE: 没有时间局部性，不需要进入缓存；可以预取，可以合并。

$\triangle$ If a Load Non-Temporal Pair instruction specifies the same register for the two registers that are being loaded, then behavior is CONSTRAINED UNPREDICTABLE and one of the following must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all the loads using the specified addressing mode and the register that is loaded takes an UNKNOWN value.

###### Table C3-20 Load/store non-temporal pair instructions

$\triangle$ `LDNP`, `STNP`.

### C3.2.5 Load/store unprivileged

$\triangle$ The load/store unprivileged instructions support only one addressing mode: Base plus an unscaled 9-bit signed immediate offset.

$\triangle$ The access permissions that apply to accesses made at EL0 applying to the memory accesses made by a load/store unprivileged instruction that is executed either:
- At EL1 when the *Effective value* of PSTATE.UAO is 0.
- At EL2 when both the *Effective value* of HCR_EL2.{E2H, TGE} is {1, 1} and the *Effective value* of PSTATE.UAO is 0.

$\triangle$ Otherwise, memory accesses made by a load/store unprivileged instruction are subject to the access permissions that apply to the Exception level at which the instruction is executed. There are the permissions that apply to the corresponding load/store register instruction.

$\triangle$ This means that when the value of PSTATE.UAO is 1 the access permissions for a load/store unprivileged instruction are always the same as those for the corresponding load/store register instruction.

###### Table C3-21 Load-Store unprivileged instructions

$\triangle$ `LDTR`, `LDTRB`, `LDTRSB`, `LDTRH`, `LDTRSH`, `LDTRSW`, `STTR`, `STTRB`, `STTRH`.

### C3.2.6 Load-Exclusive/Store-Exclusive

$\triangle$ The Load-Exclusive/Store-Exclusive instructions support only one addressing mode: Base register with no offset.

$\triangle$ The Load-Exclusive instructions mark the physical address being accessed as an exclusive access. The exclusive access mark is checked by teh Store-Exclusive instruction, permitting the construction of atomic read-modify-write operations on shared memory variables, semaphores, mutexes, and spinlocks.

$\triangle$ If FEAT_LSE2 is not implemented that:
- The Load-Exclusive/Store-Exclusive instructions other than Load-Exclusive pair and Store-Exclusive pair require natural alignment, and an unaligned address generates an Alignment fault.
- Memory accesses generated by Load-Exclusive pair or Store-Exclusive pair instructions must be aligned to the size of the pair, otherwise the access generates an Alignment fault.

$\triangle$ When a Store-Exclusive pair succeeds, it causes a single-copy atomic update of the entire memory location being stored to.

###### Table C3-22 Load-Exclusive/Store-Exclusive instructions

$\triangle$ `LDXR`, `LDXRB`, `LDXRH`, `LDXP`, `STXR`, `STXRB`, `STXRH`, `STXP`.

### C3.2.7 Load-Acquire/Store-Release

$\triangle$ The Load-Acquire, Load-AcquirePC, and Store-Release instructions support only one addressing mode: Base register with no offset.

$\triangle$ The Load-Acquire, Load-AcquirePC, and Store-Release instructions can remove the requirement to use the explicit DMB memory barrier instruction.

$\triangle$ The Load-Acquire, Load-AcquirePC, and Store-Release instructions other than Load-Acquire pair and Store-Release pair require natural alignment, and an unaligned address generates an Alignment fault. Memory accesses generated by Load-Acquire pair or Store-Release pair instructions must be aligned to the size of the pair, otherwise the access generates an Alignment fault.

$\triangle$ A Store-Release Exclusive instruction has the Release semantics only if the store is successful.

$\triangle$ FEAT_LRCPC2 introduces changes to the alignment requirements of Load-Acquire/Store-Release instructions.

###### Table C3-23 Non-exclusive Load-Acquire and Store-Release instructions

$\triangle$ `LDAPR`, `LDAPRB`, `LDAPRH`, `LDAPUR`, `LDAPURB`, `LDAPURH`, `LDAPURSB`, `LDAPURSH`, `LDAPURSW`, `LDAR`, `LDARB`, `LDARH`, `STLR`, `STLRB`, `STLRH`, `STLUR`, `STLURB`, `STLURH`. 

###### Table C3-24 Exclusive Load-Acquire and Store-Release instructions

$\triangle$ `LDAXR`, `LDAXRB`, `LDAXRH`, `LDAXP`, `STLXR`, `STLXRB`, `STLXRH`, `STLXP`.

### C3.2.8 LoadLOAcquire/StoreLORelease

$\triangle$ The LoadLOAcquire/StoreLORelease instructions support only one addressing mode: Base register with no offset.

$\triangle$ The LoadLOAcquires/StoreLORelease instructions can remove the requirement to use the explicit DMB memory barrier instruction. 

$\triangle$ The LoadLOAcquire/StoreLORelease instructions require natural alignment, and an unaligned address generates an Align fault.

###### Table C3-25 LoadLOAcquire and StoreLORelease instructions

$\triangle$ `LDLARB`, `LDLARH`, `LDLAR`, `STLLRB`, `STLLRH`, `STLLR`.

### C3.2.9 Load/store scalar SIMD and floating-point

$\triangle$ The load/store scalar SIMD and floating-point instructions operate on scalar values in the SIMD and floating-point register file. The memory addressing modes available are identical to the general-purpose register load/store instructions, and like those instructions permit arbitrary address alignment unless strict alignment checking is enabled. However, unlike the load/store instructions that transfer general-purpose registers, load/store scalar SIMD and floating-point instructions make no guarantee of atomicity, even when the address is naturally aligned to the size of the data.

#### Load/store scalar SIMD and floating-point register

$\triangle$ The load/store scalar SIMD and floating-point register instructions support the following addressing modes:
- Base plus a scaled 12-bit unsigned immediate offset or base plus unscaled 9-bit signed immediate offset.
- Base plus 64-bit register offset, optionally scaled.
- Base plus 32-bit extended register offset, optionally scaled.
- Pre-indexed by an unscaled-9bit signed immediate offset.
- Post-indexed by an unscaled-9bit signed immediate offset.
- PC-relative literal for loads of 32 bits or more.

$\triangle$  The unscaled 9-bit signed immediate offset address mode requires its own instruction form.

###### Table C3-26 Load/store single SIMD and floating-point register instructions

$\triangle$ `LDR`, `STR`.

#### Load/store scalar SIMD and floating-point register (unscaled offset)

$\triangle$ The load/store scalar SIMD and floating-point register instructions support only one addressing mode: Base plus an unscaled 9-bit signed immediate offset.

$\triangle$ The load/store scalar SIMD and floating-point register (unscaled offset) instructions are required to disambiguate this instruction class from the load/store single SIMD and floating-point instruction forms that support an addressing mode of base plus a scaled, unsigned 12-bit immediate offset. The is similar to the load/store register (unscaled offset) instructions, that disambiguate this instruction class from the load/store register instruction.

###### Table C3-27 Load/store SIMD and floating-point register instructions

$\triangle$ `LDUR`, `STUR`.

#### Load/store SIMD and floating-point register pair

$\triangle$ The load/store SIMD and floating-point register pair instructions support the following addressing modes:
- Base plus a scaled 7-bit signed immediate offset.
- Pre-indexed by a scaled 7-bit signed immediate offset.
- Post-indexed by a scaled 7-bit signed immediate offset.

$\triangle$ If a Load pair instruction specifies the same register for the two registers that are being loaded, then behavior is CONSTRAINED UNPREDICTABLE and one the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all of the loads using the specified addressing mode and the register being loaded takes an UNKNOWN value.

###### Table C3-28 Load/store SIMD and floating-point register pair instructions

$\triangle$ `LDP`, `STP`.

#### Load/store SIMD and floating-point non-temporal pair

$\triangle$ The load/store SIMD and floating-point non-temporal pair instructions support only one addressing mode: Base plus a scaled 7-bit signed immediate offset.

$\triangle$ The load/store non-temporal pair instructions provide a hint to the memory system that an access is non-temporal or streaming, and unlikely to be repeated in the near feature. This means that data caching is not required. However, depending on the memory type, the instructions might permit memory reads to be preloaded and memory writes to be gathered to accelerate bulk memory transfers.

$\triangle$ In addition, there is an exception to the usual memory ordering rules. If an address dependency exists between two memory reads, and a load non-temporal pair instruction generated the second read, then in the absence of any other barrier mechanism to achieve order, those memory access can be observed in any order by the other observers within the shareability domain of the memory addresses being accessed.

$\triangle$ If a load non-temporal pair instruction specifies the same register for the two registers that are being loaded, then behavior is CONSTRAINED UNPREDICTABLE and one of the following behaviors must occur:
- The instruction is treated as UNDEFINED.
- The instruction is treated as a NOP.
- The instruction performs all the loads using the specified addressing mode and the register that is loaded takes an UNKNOWN value.

###### Table C3-29 Load/store SIMD and floating-point non-temporal pair instructions

$\triangle$ `LDNP`, `STNP`.

### C3.2.10 Load/store Advanced SIMD

$\triangle$ The Advanced SIMD load/store structure instructions support the following addressing mode:
- Base register only.
- Post-indexed by a 64-bit register.
- Post-indexed by an immediate, equal to the number of bytes transferred.

$\triangle$ Load/store vector instructions, like other load/store instructions, allow any address alignment, unless strict alignment checking is enabled. If strict alignment checking is enabled, then alignment checking to the size of the element is performed. However, unlike the load/store instructions that transfer general-purpose registers, the load/store vector instructions do not guarantee atomicity, even when the address is naturally aligned to the size of the element.

#### Load/store structures

$\triangle$ A post-increment immediate offset, if present, must be 8, 16, 24, 32, 48, or 64, depending on the number of elements transferred.

###### Table C3-30 Load/store multiple structures instructions

$\triangle$ `LD1`, `LD2`, `LD3`, `LD4`, `ST1`, `ST2`, `ST3`, `ST4`.

#### Load single structure and replicate

$\triangle$ A post-increment immediate offset, if present, must be 1, 2, 3, 4, 6, 8, 12, 16, 24, or 32, depending on the number of elements transferred.

###### Table C3-31 Load single structure and replicate instructions

$\triangle$ `LD1R`, `LD2R`, `LD3R`, `LD4R`.

### C3.2.11 Prefetch memory

$\triangle$ The Prefetch memory instructions support the following addressing modes:
- Base plus a scaled 12-bit unsigned immediate offset or base plus an unscaled 9-bit signed immediate offset.
- Base plus a 64-bit register offset. This can be optionally scaled by 8-bits.
- Base plus a 32-bit extended register offset. This can be optionally scaled by 8-bits
- PC-relative literal.

$\triangle$ The prefetch memory instructions signal to the memory system that memory accesses from a specified address are likely to occur in the near future. The memory system can respond by talking actions that are expected to speed up the memory access when they do occur, such as preloading the specified address into one or more caches. Because these signals are only hints, it is valid for the PE to treat any or all prefetch instructions as a `NOP`.

$\triangle$ Because they are hints to the memory system, the operation of a `PRFM` instruction cannot cause a synchronous exception. However, a memory operation performed as a result of one of these memory system hints might in exceptional cases trigger an asynchronous event, and thereby influence the execution of the PE. An example of an asynchronous event that might be triggered is an SError interrupt.

$\triangle$ A `PRFM` instruction can only have an effect on software visible structures, such as caches and translation lookaside buffers associated with memory locations that can be accessed by reads, writes or execution as defined in the translation regime of the current Exception level.

$\triangle$ A `PRFM` instruction is guaranteed not to access Device memory.

$\triangle$ A `PRFM` instruction using a `PLI` hint must not result in any access that could not be performed by the PE speculatively fetching an instruction. Therefore, if all associated MMUs are disabled, a `PLI` hint cannot access any memory location that cannot be accessed by instruction fetches.

$\triangle$ The `PRFM` instructions require an additional `<prfop>` operand to be specified, which must be one of the following: `PLDL1KEEP`, `PLDL1STRM`, `PLDL2KEEP`, `PLDL2STRM`, `PLDL3KEEP`, `PLDL3STRM`, `PSTL1KEEP`, `PSTL1STRM`, `PSTL2KEEP`, `PSTL2STRM`, `PSTL3KEEP`, `PSTL3STRM`, `PLIL1KEEP`, `PLIL1STRM`, `PLIL2KEEP`, `PLIL2STRM`, `PLIL3KEEP`, `PLIL3STRM`.

$\triangle$ `<prfop>` is defined as \<type\>\<target\>\<policy\>.
- \<type\> is one of `PLD` (Prefetch for load), `PST` (Prefetch for store), `PLI` (Preload instructions).
- \<target\> is one of `L1` (Level 1 cache), `L2` (Level 2 cache), `L3` (Level 3 cache).
- \<policy> is one of `KEEP` (Retained or temporal prefetch, allocated in the cache normally), `STRM` (Streaming or non-temporal prefetch, for data that is used only once).

$\triangle$ `PRFUM` explicitly uses the unscaled-9bit signed immediate offset addressing mode.

###### Table C3-32 Prefetch memory instructions

$\triangle$ `PRFM`, `PFRUM`

### C3.2.12 Atomic instructions

$\triangle$ The atomic instructions perform atomic read and write operations on a memory location such that the architecture guarantees that no modification of that memory location by another observer can occur between the read and the write defined by that instruction.

#### Atomic memory operations

$\triangle$ The atomic memory operation instructions support only one addressing mode: Base register only.

$\triangle$ For the purpose of permission checking, and for watchpoints, all of the Atomic memory operation instructions are treated as performing both a load and a store.

$\triangle$ If FEAT_LES2 is not implemented that the `LD<OP>` and `ST<OP>` instructions require natural alignment, and an unaligned address generates an Alignment fault.

$\triangle$ The instructions are provided with ordering options, which map to the acquire and release definitions used in the architecture. The atomic instructions with release semantics have the same rules as Store-Release instructions regarding multi-copy atomicity. These operations map to the acquire and release definitions, and are counted as Load-Acquire and Store-Release operations respectively.

$\triangle$ For the `LD<OP>` instructions, where the source and destination registers are the same, if the instruction generates a synchronous Data Abort, then the source register is restored to the value it held before the instruction was executed.

$\triangle$ The `ST<OP>` instructions, and `LD<OP>` instructions where the destination register is WZR or XZR, are not regarded as doing a read for the purpose of a `DMB LD` barrier.

###### Table C3-33 Atomic memory operation instructions

$\triangle$ `LDADD`, `LDADDB`, `LDADDH`, `LDCLR`, `LDCLRB`, `LDCLRH`, `LDEOR`, `LDEORB`, `LDEORH`, `LDSET`, `LDSETB`, `LDSETH`, `LDMAX`, `LDMAXB`, `LDMAXH`, `LDMIN`, `LDMINB`, `LDMINH`, `LDUMAX`, `LDUMAXB`, `LDUMAXH`, `LDUMIN`, `LDUMINB`, `LDUMINH`, `STADD`, `STADDB`, `STADDH`, `STCLR`, `STCLRB`, `STCLRH`, `STEOR`, `STEORB`, `STEORH`, `STSET`, `STSETB`, `STSETH`, `STMAX`, `STMAXB`, `STMAXH`, `STMIN`, `STMINB`, `STMINH`, `STUMAX`, `STUMAXB`, `STUMAXH`, `STUMIN`, `STUMINB`, `STUMINH`.

#### Single-copy atomic 64-byte load/store

$\triangle$ If FEAT_LS64 is implemented, the following instructions are implemented: LD64B, ST64B.

$\triangle$ If FEAT_LS64_V is implemented, the following instructions are implemented: LD64B, ST64B, ST64BV. 

$\triangle$ if FEAT_LS64_ACCDATA is implemented, the following instructions are implemented: LD64B. ST64B, ST64BV, ST64BV0.

$\triangle$ The single-copy atomic 64-byte load/store instructions support one addressing mode: Base register only.

$\triangle$ The memory location accessed by the instruction is required to be aligned on a 64-byte boundary, otherwise an Alignment fault occurs.

$\triangle$ When the instructions access a memory type that is not one of the following, a data abort for unsupported Exclusive or atomic access is generated for the stage of translation that provided the memory type:
- Normal Inner Non-cacheable, Outer Non-cacheable.
- Device-GRE.
- Device-nGRE.
- Device-nGnRE.
- Device-nGnRnE.

$\triangle$ Regardless of the memory type:
- The memory access generated by an ST64BV or ST64BV0 instruction is not merged with any access.
- The memory access generated by an ST64B instruction is not merged with any accesses generated by store instructions appearing in program order after this instruction.

###### Table C3-34 Single-copy atomic 64-byte load/store instructions

$\triangle$ `LD64B`, `ST64B`.

###### Table C3-35 Single-copy atomic 64-byte store with return instructions

$\triangle$ `ST64BV`.

###### Table C3-36 Single-copy atomic 64-byte EL0 store with return instructions

$\triangle$ `ST64BV0`.

#### Swap

$\triangle$ The swap instructions support only one addressing mode: Base register only.

$\triangle$ For the purpose of permission checking, and for watchpoints, all of the Swap instructions are treated as performing both a load and a store.

$\triangle$ If FEAT_LSE2 is not implemented, then the SWP instructions require natural alignment, and an unaligned address generates an Alignment fault. 

$\triangle$ The instructions are provided with ordering options, which map to the acquire and release definitions used in the architecture. The atomic instructions with release semantics have the same rules as Store-Release instructions regarding multi-copy atomicity.

$\triangle$ For the `SWP` instructions, where the source and destination registers are the same, if the instruction generates a synchronous Data Abort, then the source register is restored to the value it held before the instruction as executed.

###### Table C3-37 Swap instructions

$\triangle$ `SWP`, `SWPB`, `SWPH`.

#### Compare and Swap

$\triangle$ The Compare and Swap instructions support only one addressing mode: Base register only.

$\triangle$ For the purpose of permission checking, and for watchpoints, all of the Compare and Swap instructions are treated as performing both a load and store.

$\triangle$ If FEAT_LSE2 is not implemented then:
- The `CAS` instructions require natural alignment.
- THe `CASP` instructions require alignment to the total size of the memory being accessed.

$\triangle$ The instructions are provided with ordering options, which map to the acquire and release definitions used in the architecture. If a compare and swap instruction does not perform a store, then the instruction does not have release semantics, regardless of the instruction ordering options.

$\triangle$ The atomic instructions with release semantics have the same rules as Store-Release instructions regarding multi-copy atomicity.

$\triangle$ For the `CAS` and `CASP` instructions, the architecture permits that a data read clears any Exclusives monitors associated with that location, even if the compare subsequently fails. If these instructions generate a synchronous Data Abort, the registers which are compared and loaded are restored to the values held in the registers before the instruction was executed.

###### Table C3-38 Compare and swap instructions

### C3.2.13 Memory Tagging instructions

###### Table C3-39 Tag generation instructions

$\triangle$ `ADDG`, `GMI`, `IRG`, `SUBG`.

###### Table C3-40 Pointer Arithmetic

$\triangle$ `SUBP(S)`.

###### Table C3-41 Tag setting instructions

$\triangle$ `STG`, `STZG`, `ST2G`, `STZ2G`, `STGP`.

###### Table C3-42 Tag getting instructions

$\triangle$ `LDG`.

###### Table C3-43 Bulk Allocation Tag access

$\triangle$ `LDGM`, `STGM`, `STZGM`.

### C3.2.14 Memory Copy and Memory Set instructions

$\triangle$ If FEAT_MOPS is implemented, the `CPY*`, `SETE*`, `SETM*`, and `SETP*` instructions described in this section are implemented. If FEAT_MOPS and FEAT_MTE are implemented, the `SETG*` instructions described in this section are also implemented. Collectively, the instructions described in this section are referred to as *Memory Copy and Memory Set* instructions.

$\triangle$ To perform a memory copy or memory set, three instructions - a prologue, then a main, and then an epilogue - are expected to be run in succession, with no instruction appearing in the code between them:
- To perform a memory copy, forward-only: `CPYFP*`, then `CPYFM*`, and then `CPYFE*`.
- To perform a memory copy, forward or backward: `CPYP*`, then `CPYM*`, and then `CPYE*`.
- To perform a memory set with tag setting: `SETGP*`, then `SETGM*`, and then `SETGE*`.
- To perform a memory set without tag setting: `SETP*`, then `SETM*`, and then `SETE*`.

$\triangle$ The variant of each instruction is also expected to be the same throughout one of these sequences. For example,
`CPYFPWTWN`, `CPYFMWTWN`, `CPYFEWTWN`.

$\triangle$ Fetching of a Memory Copy and Memory Set instruction multiple times during its execution is permissible.

$\triangle$ Memory Copy and Memory Set exceptions can be generated by execution of Memory Copy and Memory Set instructions restarting on a physical hardware PE implementation that is different from the physical hardware PE implementation that an exception was taken from. 

$\triangle$ If an exception is taken during the execution of a Memory Copy and Memory Set instruction, that instruction has not been executed for the purposes of instruction counting, instruction tracing, statistical profiling, or single stepping.

$\triangle$ For the purposes of single stepping and performance monitoring, each Memory Copy and Memory Set instruction is regarded as a single instruction that performs a store and, in the case of `CPY*` instructions, also performs a load.

$\triangle$ For Memory Copy and Memory Set instructions, the following are not architecturally defined:
- The size of the memory transactions they create.
- The order between accesses to different addresses.

$\triangle$ The `CPY*` instructions are guaranteed to make forward progress if none of the following four leaf level translation table entries fault:
- The source leaf level translation table entry held in Xs.
- The next leaf level translation table entry, as determined by the copy direction, adjacent to the source leaf level translation table entry held in Xs.
- The destination leaf level translation table entry held in Xd.
- The next leaf level translation table entry, as determined by the copy direction, adjacent to the destination leaf level translation table entry held in Xd.

$\triangle$ The `SET*` instructions are guaranteed to make forward progress if neither of the following two leaf level translation table entries fault:
- The destination leaf level translation table entry held in Xd.
- The next leaf level translation table entry adjacent to the destination leaf level translation table entry held in Xd.

$\triangle$ The forward progress described in this section can be achieved by ensuring that, when a memory management fault is encountered, all bytes leading up to the fault have been operated on.

###### Table C3-44 Memory copy, forward-only instructions

$\triangle$ `CPYFE`, `CPYFEN`, `CPYFERN`, `CPYFERT`, `CPYFERTN`, `CPYFERTRN`, `CPYFERTWN`, `CPYFET`, `CPYFETN`, `CPYFETRN`, `CPYFETWN`, `CPYFEWN`, `CPYFEWT`, `CPYFEWTN`, `CPYFEWTRN`, `CPYFMWTWN`, `CPYFM`, `CPYFMN`, `CPYFMRN`, `CPYFMRT`, `CPYFMRTN`, `CPYFMRTRN`, `CPYFMRTWN`, `CPYFMT`, `CPYFMTN`, `CPYFMTRN`, `CPYFMTWN`, `CPYFMWN`, `CPYFMWT`, `CPYFMWTN`, `CPYFMWTRN`, `CPYFMWTWN`, `CPYFP`, `CPYFPN`, `CPYFPRN`, `CPYFPRT`, `CPYFPRTN`, `CPYFPRTRN`, `CPYFPRTWN`, `CPYFPT`, `CPYFPTN`, `CPYFPTRN`, `CPYFPTWN`, `CPYFPWN`, `CPYFPWT`, `CPYFPWTN`, `CPYFPWTRN`

###### Table C3-45 Memory copy, forward or backward instructions

$\triangle$ `CPYE`, `CPYEN`, `CPYERN`, `CPYERT`, `CPYERTN`, `CPYERTRN`, `CPYERTWN`, `CPYET`, `CPYETN`, `CPYETRN`, `CPYETWN`, `CPYEWN`, `CPYEWT`, `CPYEWTN`, `CPYEWTRN`, `CPYMWTWN`, `CPYM`, `CPYMN`, `CPYMRN`, `CPYMRT`, `CPYMRTN`, `CPYMRTRN`, `CPYMRTWN`, `CPYMT`, `CPYMTN`, `CPYMTRN`, `CPYMTWN`, `CPYMWN`, `CPYMWT`, `CPYMWTN`, `CPYMWTRN`, `CPYMWTWN`, `CPYP`, `CPYPN`, `CPYPRN`, `CPYPRT`, `CPYPRTN`, `CPYPRTRN`, `CPYPRTWN`, `CPYPT`, `CPYPTN`, `CPYPTRN`, `CPYPTWN`, `CPYPWN`, `CPYPWT`, `CPYPWTN`, `CPYPWTRN`, `CPYPWTWN`.

###### Table C3-46 Memory set with tag setting instructions

$\triangle$ `SETGE`, `SETGEN`, `SETGET`, `SETGETN`, `SETGM`, `SETGMN`, `SETGMT`, `SETGMTN`, `SETGP`, `SETGPN`, `SETGPT`, `SETGPTN`.

###### Table C3-47 Memory set without tag setting instructions

$\triangle$ `SETE`, `SETEN`, `SETET`, `SETETN`, `SETM`, `SETMN`, `SETMT`, `SETMTN`, `SETP`, `SETPN`, `SETPT`, `SETPTN`.

## C3.3 Loads and stores - SVE

$\triangle$ SVE vector load ans store instructions transfer data in memory to or from elements of one or more vector or predicate transfer registers. SVE also includes vector prefetch instructions that provide read and write hints to the memory system. For SVE predicated load, store, and prefetch instructions, the memory element access size and type that is associated with each vector element is specified by a suffix to the instruction mnemonic, independently of the element size of the transfer registers. 

$\triangle$ The element size of the transfer registers is always greater than or equal to the memory element access size. When the element size of the transfer registers is strictly greater than the memory element access size, then these are referred to as unpacked data accesses. In the case of unpacked data accesses:
- For load instructions, each element access is sign-extended or zero-extended to fill the vector element, according to its memory element access size and type.
- For store instructions, each vector elements is truncated to the memory element access size.

$\triangle$ Where the vector element size and the memory element access size are the same, then these are referred to as packed data accesses. Signed access types are not supported for packed data accesses. Packed and unpacked access sizes and types relate to the vector element size of the transfer registers.

$\triangle$ For gather-load and scatter-store instructions, the vector element size can only be .S or .D. This means that any non-contiguous memory element access of less than a word is unpacked. Non-contiguous memory element accesses of a word can be either packed or unpacked, depending on the vector element size.

$\triangle$ All predicated load instructions zero the *Inactive elements* of the destination vector, except for Non-fault loads and First-fault loads when the corresponding FFR element is FALSE.

$\triangle$ Prefetch instructions provide hints to hardware and do not change architectural state. Therefore, a *Governing predicate* for a prefetch instruction provides an additional hint which indicates the memory locations to be prefetched. Prefetch instructions require a prefetch operation specifier. SVE prefetch instruction support all of the prefetch operations except for the PLI prefetch operand types.

$\triangle$ Load, store, and prefetch instructions that multiply a scalar index register or an index vector element by the memory element access size specify a sift type, followed by a shift amount in bits. The shift type can be one of `LSL`, `SXTW`, or `UXTW`. The shift amount is always Log~2~ of the memory element access size, in bytes. The shift amount defaults to zero when the memory element access size is a byte, and the shift size can be omitted. The shift type of `LSL` must be omitted if the shift amount is omitted.

$\triangle$ When included as part of the assembler syntax for an instruction, `MUL VL` indicates that the specified immediate index value is multiplied by the size of the addressed vector or predicate in memory, measured in bytes, irrespective of predication. FOr a detailed description of the meaning of this assembler syntax for each instruction. When used in pseudocode, the symbol `VL` represents the vector length, measured in bits.

$\triangle$ SVE load, store and prefetch instructions do not support pre-indexed or post-indexed addressing.

### C3.3.1 Predicated single vector contiguous element accesses

$\triangle$ Predicated contiguous load and store instructions access memory locations starting from an address that is defined by a scalar base register plus either:
- A scalar index register.
- An immediate index value that is in the range -8 to 7, inclusive. This defaults to zero is omitted.

$\triangle$ The predicated contiguous load and store instructions have two supporting addressing modes:
- Scalar base plus immediate index.
- Scalar base plus scalar index.

$\triangle$ Predicated contiguous prefetch instructions address memory locations in a similar manner, with the index being either:
- A scalar index register.
- An immediate index value that is in the range of -32 to 31, inclusive. This defaults to zero if omitted.

$\triangle$ For predicated contiguous load and store SVE instructions:
- The immediate index value is a vector index, not an element index. The immediate index value is multiplied by the number of vector elements, irrespective of predication, and then multiplied by the memory element access size in bytes. The result offset is incremented following each element access by the memory element access size.
- The scalar index register value is multiplied by the memory element access size in bytes. The index value is incremented by one after each element access, but the scalar index register is not updated by the instruction.
- When alignment checking is enabled for loads and stores, the value of the base address register must be aligned to the memory element access size.

###### Table C3-48 Predicated single vector contiguous element accesses

$\triangle$ `LD1`, `ST1`, `LDFF1`, `LDNF1`, `LDNT1`, `STNT1`, `PRF`.

### C3.3.2 Predicated multiple vector contiguous structure load/store

$\triangle$ Predicated multiple vector contiguous structure load/store instructions are defined by a scalar base register plus either:
- A scalar index register.
- An immediate index that is a multiple of N, in the range -8xN to 7xN, inclusive. This default to zero if omitted.

$\triangle$ The predicated contiguous structure load and store instructions have two supporting addressing modes:
- Scalar base plus immediate index.
- Scalar base plus scalar index.

$\triangle$ For the predicated multiple vector contiguous structure load/store SVE instructions:
- The immediate index value is a vector index, not an element index. The immediate index value is multiplied by the number of vector elements, irrespective of predication, and then multiplied by the memory element access size in bytes. The resulting offset is incremented following each element access by the memory element access size.
- The scalar index register value is multiplied by the memory element access size in bytes. Following each element access, the index value is incremented by one but the instruction does not update the scalar index register.
- Each predicate element applies to a single structure in memory, or equivalently to the same element number within each of the two, three, or four transferred vector registers.
- These instructions support packed data accesses only.
- When alignment checking is enabled for loads and stores, the base address must be aligned to the element access size.

###### Table C3-49 Predicated multiple vector contiguous structure load/store

$\triangle$ `LD2`, `LD3`, `LD4`, `ST2`, `ST3`, `ST4`.

### C3.3.3 Predicated non-contiguous element access

$\triangle$ Predicated non-contiguous element accesses address non-contiguous memory locations that are specified by either:
- A scalar base register plus a vector of indices or offsets.
- A vector of base addresses plus an immediate byte offset. The immediate byte offset is a multiple of the memory element access size, in the range 0 to 31 times the memory element access size, inclusive, and defaults to zero if omitted.

$\triangle$ The predicated non-contiguous element accesses have two supporting addressing modes:
- Scalar base plus 64-bit vector index.
- Scalar base plus 32-bit vector index.
- Vector base plus immediate offset.

$\triangle$ For this group of SVE instructions:
- Vector registers used as part of the address must specify a vector element size of 32 bits or 64 bits, .S or .D. For load and store instructions, the transfer register must specify the same vector element size.
- If the index vector register contains 32-bit index values then the lowest 32 bits of each index vector element can either be zero-extended or sign-extended to 64 bits.
- For load and store instructions, the index vector elements are then optionally multiplied by the memory element access size, in bytes, if a shift amount is specified. For prefetch instructions, the index vector elements are always multiplied by the memory element access size, in bytes.
- When alignment checking is enabled for loads and stores, the computed virtual address of each element must be aligned to the memory element access size.

###### Table C3-50 Predicated non-contiguous element accesses

$\triangle$ `LD1`, `ST1`, `LDFF1`, `PRF`.

### C3.3.4  Predicated replicating element loads

$\triangle$ The load and replicate instructions read one or more contiguous memory locations starting from an address that is defined by a scalar base register plus either:
- A scalar index register.
- An immediate byte offset.

$\triangle$ The predicated contiguous load and store instructions have two supporting addressing modes:
- Scalar base plus immediate offset.
- Scalar base plus scalar index.

$\triangle$ This defaults to zero if omitted. For predicated replicating element load SVE instructions:
- When alignment checking is enabled, the base address must be aligned to the memory element access size.

###### Table C3-51 Predicated replicating element loads

$\triangle$ `LD1RB`, `LD1RD`, `LD1RH`, `LD1RW`, `LD1RQB`, `LD1RQD`, `LD1RQH`, `LD1RQW`.

### C3.3.5 Unpredicated vector register load/store

$\triangle$ The unpredicated vector register load, LDR, and store, STR, instructions transfer a single vector register from or to memory locations that are specified by a scalar base register plus an immediate index value that is in the range -256 to 255, inclusive. The immediate index value defaults to zero if omitted.

$\triangle$ The unpredicated vector register load/store instructions have one supporting addressing mode:
- Scalar base plus immediate index.

$\triangle$ For the unpredicated vector register load/store SVE instructions:
- The immediate index value is a vector index, not an element index. The immediate index value is multiplied by the current vector register length in bytes.
- The data transfer is performed as a contiguous stream of byte accesses in ascending element order, without endianness conversion.
- When alignment checking is enabled for loads and stores, the base address must be 16-byte aligned.

###### Table C3-52 Unpredicated vector register load/store

$\triangle$ `LDR`, `STR`.

### C3.3.6 Unpredicated predicate register load/store

$\triangle$ The unpredicated predicate register load, LDR, and store, STR, instructions transfer a single predicate register from or to memory locations that are specified by a scalar base register plus an immediate index value that is in the range -256 to 255, inclusive. The immediate index value defaults to zero if omitted.

$\triangle$ The unpredicated predicate register load/store instructions have one supporting addressing mode:
- Scalar base plus immediate index.

$\triangle$ For unpredicated predicate register load/store SVE instructions:
- The immediate index value is a predicate index, not an element index. The immediate index value is multiplied by the current predicate register length, in bytes.
- The data transfer is performed as a contiguous stream of byte accesses, each byte containing 8 consecutive predicate bits, in ascending bit and element order, without endian conversion.
- When alignment checking is enabled for loads and stores, the base address must be 2-byte aligned.

###### Table C3-52 Unpredicated predicate register load/store

$\triangle$ `LDR`, `STR`.

## C3.4 Data processing - immediate

### C3.4.1 Arithmetic (immediate)

$\triangle$ The Arithmetic (immediate) instructions accept a 12-bit unsigned immediate value, optionally shifted left by 12 bits.

$\triangle$ The Arithmetic (immediate) instructions that do not set Conditional flags can read from and write to the current stack pointer. The flag setting instructions can read from the stack pointer, but they cannot write to it.

> 为什么呢？

###### Table C3-54 Arithmetic instructions with an immediate

$\triangle$ `ADD`, `ADDS`, `SUB`, `SUBS`, `CMP`, `CMN`.

### C3.4.2 Logical (immediate)

$\triangle$ The Logical (immediate) instructions accept a bitmask immediate value that is a 32-bit pattern or a 64-bit pattern viewed as a vector of identical elements of size e=2,4,8,16,32 or, 64 bits. Each element contains the same sub-pattern, that is a single run of 1 to (e-1) nonzero bits from bit 0 followed by zero bits, then rotated by 0 to (e-1) bits. This mechanism can generate 5334 unique 64-bit patterns as 2667 pairs of pattern and their bitwise inverse.

$\triangle$ Values that consist of only zeros or only ones cannot be described in this way.

$\triangle$ The Logical (immediate) instructions that do not set the Conditional flags can write to the current stack pointer, for example to align the stack pointer in a function prologue.

$\triangle$ Apart from `ANDS` and its `TST` alias, Logical (immediate) instructions do not set the Conditional flags. However, the final results of a bitwise operation can be tested by a `CBZ`, `CBNZ`, `TBZ`, or `TBNZ` conditional branch.

###### Table C3-55 Logical immediate instructions

$\triangle$ `AND`, `ANDS`, `EOR`, `ORR`, `TST`.

### C3.4.3 Move (wide immediate)

$\triangle$ The Move (wide immediate) instructions insert a 16-bit immediate, or inverted immediate, into a 16-bit aligned position in the destination register. The value of the other bits in the destination register depends on the variant used. The optional shift amount can be any multiple of 16 that is smaller than the register size.

###### Table C3-56 Move (wide immediate) instructions

$\triangle$ `MOVZ`, `MOVN`, `MOVK`.

### C3.4.4 Move (immediate)

$\triangle$ The Move (immediate) instructions are aliases for a single `MOVZ`, `MOVN`, or `ORR` (immediate with zero register), instruction to load an immediate value into the destination register. An assembler must permit a signed or unsigned immediate, as long as its binary representation can be generated using one of these instructions, and an assembler error results if the immediate cannot be generated in this way. On disassembly, it is unspecified whether the immediate is output as a signed or an unsigned value.

$\triangle$ If there is a choice between the `MOVZ`, `MOVN`, and `ORR` instruction to encode the immediate, then an assembler must prefer `MOVZ` to `MOVN`, and `MOVZ` or `MOVN` to `ORR`, to ensure reversability. A disassembler must output `ORR` (immediate with zero register), `MOVZ`, and `MOVN`, as a `MOV` mnemonic except that the underlying instruction must be used when:
- `ORR` has an immediate that can be generated by a `MOVZ` or `MOVN` instruction.
- A `MOVN` instruction has an immediate that can be encoded by `MOVZ`.
- `MOVZ #0` or `MOVN #0` have a shift amount other than `LSL #0`.

###### C3-57 Move (immediate) instructions

$\triangle$ `MOV`.

### C3.4.5 PC-relative address calculation

$\triangle$ The `ADR` instruction adds a signed, 21-bit immediate to the value of the program counter that fetched this instructions, and then writes the result to a general-purpose register. This permits the calculation of any byte address within $\pm$ 1MB of the current PC.

$\triangle$ The `ADRP` instruction shifts a signed, 21-bit immediate left by 12-bits, adds it to the value of the program counter with the bottom 12 bits cleared to zero, and then writes the result to a general-purpose register. This permits the calculation of the address at a 4KB aligned memory region. In conjunction with an `ADD` (immediate) instruction, or a load/store instruction with a 12-bit immediate offset, this allows for the calculation of, or access to, any address within $\pm$ 4GB of the current PC. 

$\triangle$ The term *page* used in the `ADRP` instruction is short-hand for the 4KB memory region, and is not related to the virtual memory translation granule size.

###### Table C3-58 PC-relative address calculation instructions

$\triangle$ `ADRP`, `ADR`.

### C3.4.6 Bitfield move

$\triangle$ The Bitfield move instructions copy a field of constant width from bit 0 in the source register to a constant bit position in the destination register, or from a constant bit position in the source register to bit 0 in the destination register. The remaining bits in the destination register are set as follows:
- For `BFM`, the remaining bits are unchanged.
- For `UBFM` the lower bits, if any, and upper bits, if any, are set to zero.
- For `SBFM`, the lower bits, if any, are set to zero, and the upper bits, if any, are set to a copy of the most-significant bit in the copied field.

###### Table C3-59 Bitfield move instructions

$\triangle$ `BFM`, `SBFM`, `UBFM`.

### C3.4.7 Bitfield insert and extract

$\triangle$ The Bitfield insert and extract instructions are implemented as aliases of the Bitfield move instructions.

###### Table C3-60 Bitfield insert and extract instructions

$\triangle$ `BFC`, `BFI`, `BFXIL`, `SBFIX`, `SBFX`, `UBFIZ`, `UBFX`.

### C3.4.8 Extract register

$\triangle$ Depending on the register width of the operands, the Extract register instruction copies a 32-bit or 64-bit field from a constant bit position within a double-width value formed by the concatenation of a pair of source registers to a destination register.

###### Table C3-61 Extract register instruction

$\triangle$ `EXTR`.

### C3.4.9 Shift (immediate)

$\triangle$ Shifts and rotates by a constant amount are implemented as alias of the Bitfield move or Extract register instructions. The shift or rotate amount must be in the range 0 to one less than the register width of the instruction, inclusive.

###### Table C3-62 Aliases for immediate shift and rotate instructions

$\triangle$ `ASR`, `LSL`, `LSR`, `ROR`.

### C3.4.10 Sign-extend and Zero-extend

$\triangle$ The Sign-extend and Zero-extend instructions are implemented as aliases of the Bitfield move instructions.

###### Table C3-63 Zero-extend and sign-extend instructions

$\triangle$ `SXTB`, `SXTH`, `SXTW`, `UXTB`, `UXTH`.

## C3.5 Data processing-register

### C3.5.1 Arithmetic (shifted register)

$\triangle$ The Arithmetic (shifted register) instructions apply an optional shift operator to the second source register value before performing the arithmetic operation. The register width of the instruction controls whether the new bits are fed into the intermediate result on a right shift or rotate a bit[63] or bit[31].

$\triangle$ The shift operators `LSL`, `ASR`, and `LSR` accept an immediate shift amount in the range 0 to one less than the register width of the instruction, inclusive.

$\triangle$ Omitting the shift operator implies `LSL #0`, which means that there is no shift. A disassembler must not output `LSL #0`. However, a disassembler must output all other shifts by zero.

$\triangle$ The current stack pointer, SP or WSP, cannot be used with this class of instructions.

###### Table C3-64 Arithmetic (shifted register) instructions

$\triangle$ `ADD`, `ADDS`, `SUB`, `SUBS`, `CMN`, `CMP`, `NEG`, `NEGS`.

### C3.5.2 Arithmetic (extended register)

$\triangle$ The extended register instructions provide an optional sign-extension or zero-extension of a portion of the second source register value, followed by an optional left shift by a constant amount of 1-4 inclusive.

$\triangle$ The extended shift is described by the mandatory extend operator `SXTB`, `SXTH`, `SXTW`, `UXTB`, `UXTH`, or `UXTW`. This is followed by an optional left shift amount. If the shift amount is not specified, the default shift amount is zero, A disassembler must not output a shift amount of zero.

$\triangle$ For 64-bit instruction forms, the additional operators `UXTX` and `SXTX` use all 64-bits of the second source register with an optional shift. In that case, Arm recommends `UXTX` as the operator. If and only if at least one register is SP, Arm operator and the shift amount can be omitted. `UXTW` and `SXTW` both use all 32 bits of the second source register with an optional shift. In that case Arm recommends `UXTW` as the operator. If and only if at least one register is WSP, Arm recommends use of the `LSL` operator name, rather than `UXTW`, and when the shift amount is also zero then both the operator and the shift amount can be omitted.

$\triangle$ For 32-bit instruction forms, the operators `UXTW` and `SXTW` both use all 32 bits of the second source register with an optional shift. In that case, Arm recommends `UXTW` as the operator. If and only if at least one register is WSP, Arm recommends use of the `LSL` operator name, rather than `UXTW`, and when the shift amount is also zero then both the operator and the shift amount can be omitted.

$\triangle$ The non-flag setting variants of the extended register instruction permit the use of the current stack pointer as either the destination register and the first source register. The flag setting variants only permit the stack pointer to be used as the first source register.

###### Table C3-65 Arithmetic (extended register) instructions

$\triangle$ `ADD`, `ADDS`, `SUB`, `SUBS`, `CMN`, `CMP`.

### C3.5.3 Arithmetic with carry

$\triangle$ The Arithmetic with carry instructions accept two source registers, with the carry flag as an additional input to the calculation. They do not support shifting of the second source register.

###### Table C3-66 Arithmetic with carry instructions

$\triangle$ `ADC`, `ADCS`, `SBC`, `SBCS`, `NGC`, `NGCS`

### C3.5.4 Flag manipulation instructions

$\triangle$ The Flag manipulation instructions set the value of the NZCV condition flags directly.

$\triangle$ The instructions `SETF8` and `SETF16` accept one source register and set the NZV condition flags based on the value of the input register. The instruction `RMIF` accepts one source register and two immediate values, rotating the first source register using the first immediate value and setting the NZCV condition flags masked by the second immediate value.

$\triangle$ The instructions `XAFLAG` and `AXFLAG` convert PSTATE condition flags between the FCMP instruction format and an alternative format.

###### Table C3-67 Flag manipulation instructions

$\triangle$ `AXFLAGS`, `CFINV`, `RMIF`, `SETF8`, `SETF16`, `XAFLAG`.

### C3.5.5 Logical (shifted register)

$\triangle$ The Logical (shifted register) instructions apply an optional shift operator to the second source register value before performing the main operation. The register width of the instruction controls whether the new bits are fed into the intermediate result on a right shift or rotate at bit[63] or bit[31].

$\triangle$ The shift operators `LSL`, `ASR`, `LSR`, and `ROR` accept a constant immediate shift amount in the range 0 to one less than the register width of the instruction, inclusive.

$\triangle$ Omitting the shift operator and amount implies `LSL #0`, which means that there is no shift. A disassembler must not output `LSL #0`. However, a disassembler must output all other shifts by zero.

$\triangle$ Apart from `ANDS`, `TST`, and `BICS`, the logical instructions do not set the Conditional flags, but the final result of a bit operation can usually directly control a `CBZ`, `CBNZ`, `TBZ`, or `TBNZ` conditional branch.

###### Table C3-68 Logical (shifted register) instructions

$\triangle$ `AND`, `ANDS`, `BIC`, `BICS`, `EON`, `EOR`, `ORR`, `MVN`, `ORN`, `TST`.

### C3.5.6 Move (register)

$\triangle$ The Move (register) instructions are aliases for other data processing instructions. They copy a value from a general-purpose register to another general-purpose register or the current stack pointer, or from the current stack pointer to a general-purpose register.

###### Table C3-69 MOV register instructions

$\triangle$ `MOV`.

### C3.5.7 Shift (register)

$\triangle$ In the Shift (register) instructions, the shift amount is the positive value in the second source register modulo the register size. The register width of the instruction controls whether the new bits are fed into the result on a right shift or rotate at bit[63] or bit[31].

###### Table C3-70 Shift (register) instructions

$\triangle$ `ASRV`, `LSLV`, `LSRV`, `RORV`.

###### Table C3-71 Aliases for Variable shift instructions

$\triangle$ `ASR`, `LSL`, `LSR`, `ROR`.

### C3.5.8 Multiply and divide

#### Multiply

$\triangle$ The multiply instructions write to a single 32-bit or 64-bit destination register, and are built around the fundamental four operand multiply-add and multiply-subtract operation, together with 32-bit or 64-bit widening variants. A 64-bit to 128-bit widening multiple can be constructed with two instructions, using `SMULH` or `UMULH` to generate the upper 64 bits.

###### Table C3-72 Multiply integer instructions

$\triangle$ `MADD`, `MSUB`, `MNEG`, `MUL`, `SMADDL`, `SMSUBL`, `SMNEGL`, `SMULL`, `SMULH`, `UMADDL`, `UMSUBL`, `UMNEGL`, `UMULL`, `UMULH`.

#### Divide

$\triangle$ The Divide instructions compute the quotient of a division, rounded towards zero. The remainder can then be computed as (numerator - (quotient x denominator)), using the `MSUB` instruction.

$\triangle$ If a signed integer division (`INT_MIN` / -1) is performed where `INT_MIN` is the most negative integer value representable in the selected register size, then the result overflows the signed integer range. No indication of this overflow is produced and the result that is written to the destination register is `INT_MIN`.

$\triangle$ A division by zero results in a zero being written to the destination register, without any indication that the division by zero occurred.

###### Table C3-73 Divide instructions

$\triangle$ `SDIV`, `UDIV`.

### C3.5.9 CRC32

$\triangle$ The `CRC32` instructions operate on the general-purpose register file to update a 32-bit CRC value from an input value comprising 1,2,4 or 8 bytes. There are two different classes of `CRC` instructions, `CRC32`, and `CRC32C`, that support two commonly used 32-bit polynomials, known as `CRC-32` and `CRC-32C`.

$\triangle$ To fit with common usage, the bit order of the values is reversed as part of the operation.

$\triangle$ When bits[19:16] of ID_AA64ISAR0_EL1 are set to `0b0001`, the `CRC` instructions are implemented. These instructions are optional in an Armv8.0 implementation. All implementations of Armv8.1 architecture and later are required to implement the `CRC32` instructions.

###### Table C3-74 CRC32 instructions

$\triangle$ `CRC32B`, `CRC32H`, `CRC32W`, `CRC32X`, `CRC32CB`, `CRC32CH`, `CRC32CW`, `CRC32CX`.

### C3.5.10 Bit operation

###### Table C3-75 Bit operation instructions

$\triangle$ `CLS`, `CLZ`, `RBIT`, `REV`, `REV16`, `REV32`, `REV64`.

### C3.5.11 Conditional select

$\triangle$ The Conditional select instructions select between the first or second source register, depending on the current state of the Conditional flags. When the named condition is true, the first source register is selected and its value is copied without modification to the destination register. When the condition is false the second source register is selected and its value might be optionally inverted, negated, or incremented by one, before writing to the destination register.

$\triangle$ Other useful conditional set and conditional unary operations are implemented as aliases of the four Conditional select instruction.

###### Table C3-76 Conditional select instructions

$\triangle$ `CSEL`, `CSINC`, `CSINV`, `CSNEG`, `CSET`, `CSETM`, `CINC`, `CINV`, `CNEG`.

### C3.5.12 Conditional comparison

$\triangle$ The Conditional comparison instruction provide a conditional select for the NZCV Conditional flags, setting the flags to the result of an arithmetic comparison of its two source register values if the named input condition is true, or to an immediate value if the input condition is false. There are register and immediate forms. The immediate form compares the source register to a small 5-bit unsigned value.

###### Table C3-77 Conditional comparison instructions

$\triangle$ `CCMN`, `CCMP`.

## C3.6 Data processing - SIMD and floating-point

### C3.6.1 Common features of SIMD instructions

$\triangle$ A number of SIMD instructions come in three forms:
- **Wide**. Indicated by the suffix *W*. The element width of the destination register and the first source operand is double that of the second source operand.
- **Long**. Indicated by the suffix *L*. THe element width of the destination register is double that of both source operands.
- **Narrow**. Indicated by the suffix *N*. The element width of the destination register is half that of both source operands.

$\triangle$ In addition, each vector form of the instruction is part of a pair, with a second and upper half suffix of 2, to identify the variant of the instruction:
- Where a SIMD operation widen or lengthens a 64-bit vector to a 128-bit vector, the instruction provides a second part operation that can extract the source from the upper 64 bits of the source registers.
- Where a SIMD operation narrows a 128-bit vector to a 64-bit vector, the instruction provides a second-part operation that can pack the result of a second operation into the upper part of the same destination register.

This is referred to as a *lane set specifier*.

### C3.6.2 Floating-point move (register)

$\triangle$ The Floating-point move (register) instructions copy a scalar float-point value from one register to another register without performing any conversion.

$\triangle$ Some of the Floating-point move (register) instructions overlap with the functionality provided by the Advanced SIMD instructions `DUP`, `INS`, and `UMOV`. However, Arm recommends using the `FMOV` instructions with operating on scalar floating-point data to avoid the creation of scalar floating-point code that depends on the availability of the Advanced SIMD instruction set.

###### Table C3-78 Floating-point move (register) instructions.

$\triangle$ `FMOV`.

### C3.6.3 Floating-point move (immediate)

$\triangle$ The Floating-point move (immediate) instructions convert a small constant immediate floating-point value into a half-precision, single-precision, or double-precision scalar floating-point value in a SIMD and floating-point register.

$\triangle$ The floating-point constant can be specified either in decimal notation, or as a string beginning with `0x` followed by a hexadecimal represent of the IEEE754 half-precision, single-precision, or double-precision encoding. Arm recommends that a disassembler uses the decimal notation, providing that this displays the value precisely.

$\triangle$ When FEAT_FP16 is not implemented, the only half-precision instructions that are supported are floating-point conversions between half-precision, single-precision, and double-precision.

$\triangle$ The floating-point value must be expressible as ($\pm n/16 \times 2^r$), where $n$ is an integer in the range $16\leq n\leq 31$ and $r$ is an integer in the range of $-3\leq r\leq 4$, that is a normalized binary floating-point encoding with one sign bit, four bits of fraction, and a 3-bit exponent.

###### Table C3-79 Floating-point move (immediate) instruction

$\triangle$ `FMOV`.

### C3.6.4 Floating-point conversion

#### Convert floating-point precision

$\triangle$ These instructions convert a floating-point scalar width one precision to a floating-point scalar with a different precision, using the current rounding mode as specified by FPCR.RMode.

###### Table C3-80 Floating-point precision conversion instruction

$\triangle$ `FCVT`.

#### Convert floating-point single-precision to BFloat16

$\triangle$ The `BFCVT` instruction is provided by FEAT_BF16. This instruction converts a single-precision floating-point input to BFloat16 format, honoring the FPCR rounding mode controls to give a more accurate conversion than simply removing the bottom 16 bits of the input.

###### Table C3-81 Floating-point single-precision to BFloat16 conversion instruction

$\triangle$ `BFCVT`.

#### Convert between floating-point and integer or fixed-point

$\triangle$ These instructions convert a floating-point scalar in a SIMD and floating-point register to or from a signed or unsigned integer or fixed-point value in a general-purpose register. For a fixed-point value, a final immediate operand indicates that the general-purpose register holds a fixed-point number and `fbits` indicates the number of bits after the binary point. `fbits` is in the range 1-31 inclusive for a 32-bit general-purpose register name, and 1-64 inclusive for a 64-bit general purpose register name.

$\triangle$ These instructions can cause the following floating-point exceptions:
- **Invalid Operation**. Occurs if the floating-point inputs is a NaN, infinity, or a numerical value that cannot be represented in the destination register. An out of range integer or fixed-point result is saturated to the size of the destination register.
- **Inexact**. Occurs if the numeric result that differs from the input value.
- **Input Denormal**. Can occur when zero replaces a double-precision or single-precision denormal input.

###### Table C3-82 Floating-point and integer or fixed-point conversion instructions

$\triangle$ `FCVTAS`, `FCVTAU`, `FCVTMS`, `FCVTMU`, `FCVTNS`, `FCVTNU`, `FCVTPS`, `FCVTPU`, `FCVTZS`, `FCVTZU`, `FJCVTZS`, `SCVTF`, `UCVTF`

### C3.6.5 Floating-point round to integral value

#### Floating-point round to an integer of the same size as the register

$\triangle$ The following instructions round a floating-point value to an integer floating-point value of the same size. For these instructions:
- A zero input gives a zero result with the same sign.
- An infinite input gives an infinite result with the same sign.
- A NaN is propagated as in normal floating-point arithmetic.

$\triangle$ These instructions can cause the following floating-point exceptions:
- **Invalid Operation**. Occurs in response to a floating-point input of a signaling NaN.
- **Inexact, `FRINTX` instruction only**. Occurs if the result is numeric and does not have the same numerical value as the input.
- **Input Denormal**. Can occur when zero replaces a double-precision or single-precision denormal input.

###### Table C3-83 Floating-point round to integer instructions

$\triangle$ `FRINTA`, `FRINTI`, `FRINTM`, `FRINTN`, `FRINTP`, `FRINTX`, `FRINTZ`.

#### Floating-point round to 32-bit or 64-bit integer

$\triangle$ The following instructions are present if FEAT_FRINTTS is implemented, The instructions round to a value that fits in a 32-bit integer or a 64-bit integer size, and use either round towards zero or the ambient rounding model.

$\triangle$ 
- **Invalid Operation**. Forced to be the most negative integer representable in the target size, and occurs in response to a floating-point input of a signaling NaN, an infinite input, or an out of range input.
- **Inexact**. Occurs if the result is numeric and does not have the same numerical value as the input.
- **Input Denormal**. Can occur when zero replaces a double-precision or single-precision denormal input.

###### Table C3-84 Floating-point round to integer instructions

$\triangle$ `FRINT32X`, `FRINT32Z`, `FRINT64X`, `FRINT64Z`.

### C3.6.6 Floating-point multiply-add

###### Table C3-85 Floating-point multiply-add instructions

$\triangle$ `FMADD`, `FMSUB`, `FNMADD`, `FNMSUB`.

### C3.6.7 Floating-point arithmetic (one source)

###### Table C3-86 Floating-point arithmetic instructions with one source register

$\triangle$ `FABS`, `FNEG`, `FSQRT`.

### C3.6.8 Floating-point arithmetic (two sources)

###### Table C3-87 Floating-point arithmetic instructions with two source registers

$\triangle$ `FADD`, `FDIV`, `FMUL`, `FNMUL`, `FSUB`.

### C3.6.9 Floating-point minimum and maximum

$\triangle$ The `min(x,y)` and `max(x,y)` operations return a quiet NaN when either `x` or `y` is NaN.

$\triangle$ If flushing denormalized inputs to zero is enabled, denormal operands are flushed to zero before comparison, and if the result of the comparison is the flushed value, then a zero value is returned. Where both `x` and `y` are zero, or denormal values flushed to zero, with different signs, then +0.0 is returned by `max()` and -0.0 by `min()`.

$\triangle$ The `minNum(x,y)` and `maxNum(x,y)` operations follow the IEEE754-2008 standard and return the numerical operand when one operand is numerical and the other a quiet NaN. Apart from this additional handling of a single quiet NaN, the result is then identical to `min(x,y)` and `max(x,y)`.

###### Table C3-88 Floating-point minimum and maximum instructions

$\triangle$ `FMAX`, `FMAXNM`, `FMIN`, `FMINNM`.

### C3.6.10 Floating-point comparison

$\triangle$ These instructions set the NZCV Condition flags in PSTATE, based on the result of a comparison of two operands. If the floating-point comparisons are `unordered`, where one or both operands are a form of NaN, the C and V bits are set to 1 and the N and Z bits are clear to 0.

$\triangle$ The NZCV flags in the FPSR are associated with AArch32 state. The A64 floating-point comparison instruction do not change the Condition flags in the FPSR.

$\triangle$ For the conditional Floating-point comparison instructions, if the condition is True, the flags are updated to the result of the comparison, otherwise the flags are updated to the immediate value that is defined in the instruction encoding.

$\triangle$ The quiet compare instructions generate an Invalid Operation floating-point exception if either of the source operands is a signaling NaN. The signaling compare instructions generate an Invalid Operation floating-point exception if either of the source operands is any type of NaN.

$\triangle$ If FEAT_FlagM2 is implemented, instructions AXFLAG and XAFLAG convert between the PSTATE condition flag format used by the FCMP instruction and an alternative format.

###### Table C3-89 Floating-point comparison instructions

$\triangle$ `FCMP`, `FCMPE`, `FCCMP`, `FCCMPE`.

### C3.6.11 Floating-point conditional select

###### C3-90 Floating-point conditional select instruction

$\triangle$ `FCSEL`.

### C3.6.12 SIMD move

###### C3-91 SIMD move instructions

$\triangle$ `DUP`, `INS`, `MOV`, `UMOV`, `SMOV`.

$\triangle$ `INA` disassembles as `MOV`.

### C3.6.13 SIMD arithmetic

###### Table C3-92 SIMD arithmetic instructions

$\triangle$ `ADD`, `AND`, `BIC`, `BIF`, `BIT`, `BSL`, `EOR`, `FABD`, `FADD`, `FDIV`, `FMAX`, `FMAXNM`, `FMIN`, `FMINNM`, `FMLA`, `FMLAL`, `FMLAL2`, `FMLS`, `FMLSL`, `FMLSL2`, `FMUL`, `FMULX`, `FRECPS`, `FRSQRTS`, `FSUB`, `MLA`, `MLS`, `MUL`, `MOV`, `ORN`, `ORR`, `PMUL`, `SABA`, `SABD`, `SHADD`, `SHSUB`, `SMAX`, `SMIN`, `SQADD`, `SQDMULH`, `SQRSHL`, `QSRDMLAH`, `SQRDMLSH`, `SQRDMULH`, `SQSHL`, `SQSUB`, `SRHADD`, `SRSHL`, `SSHL`, `SUB`, `UABA`, `UABD`, `UHADD`, `UHSUB`, `UMAX`, `UMIN`, `UQADD`, `UQRSHL`, `UQSHL`, `UQSUB`, `URHADD`, `URSHL`, `USHL`.

### C3.6.14 SIMD compare

$\triangle$ The SIMD compare instructions compare vector or scalar elements according to the specified condition and set the destination vector element to all one if the condition holds, or to zero if the condition does not hold.

$\triangle$ Some of the comparisons, such as LS, LE, LO, and LT, can be made by reversing the operands and using the opposite comparison, HS, GE, HI, or GT.

###### Table C3-93 SIMD compare instructions

$\triangle$ `CMEQ`, `CMHS`, `CMGE`, `CMHI`, `CMGT`, `CMLE`, `CMLT`, `CMTST`, `FCMEQ`, `FCMGE`, `FCMGT`, `FCMLE`, `FCMLT`, `FACGE`, `FACGT`.

### C3.6.15 SIMD widening and narrowing arithmetic

###### Table C3-94 SIMD widening and narrowing arithmetic instructions

$\triangle$ `ADDHN`, `ADDHN2`, `PMULL`, `PMULL2`, `RADDHN`, `RADDHN2`, `RSUBHN`, `RSUBHN2`, `SABAL`, `SABAL2`, `SABDL`, `SABDL2`, `SADDL`, `SADDL2`, `SADDW`, `SADDW2`, `SMLAL`, `SMLAL2`, `SMLSL`, `SMLSL2`, `SMULL`, `SMULL2`, `SQDMLAL`, `SQDMLAL2`, `SQDMLSL`, `SQDMLSL2`, `SQDMULL`, `SQDMULL2`, `SSUBL`, `SSUBL2`, `SSUBW`, `SSUBW2`, `SUBHN`, `SUBHN2`, `UABAL`, `UABAL2`, `UABDL`, `UABDL2`, `UADDL`, `UADDL2`, `UADDW`, `UADDW2`, `UMLAL`, `UMLAL2`, `UMLSL`, `UMLSL2`, `UMULL`, `UMULL2`, `USUBL`, `USUBL2`, `USUBW`, `USUBW2`.

### C3.6.16 SIMD unary arithmetic

###### Table C3-95 SIMD unary arithmetic instructions

$\triangle$ `ABS`, `CLS`, `CLZ`, `CNT`, `FAB`, `FCVTL`, `FCVTL2`, `FCVTN`, `FCVTN2`, `FCVTXN`, `FCVTXN2`, `FNEG`, `FRECPE`, `FRECPX`, `FRINT32X`, `FRINT32Z`, `FRINT64X`, `FRINT64Z`, `FRINTA`, `FRINTI`, `FRINTM`, `FRINTN`, `FRINTP`, `FRINTX`, `FRINTZ`, `FRSQRTE`, `FSQRT`, `NEG`, `NOT`, `RBIT`, `REV16`, `REV32`,`REV64`, `SADALP`, `SADDLP`, `SQABS`, `SQNEG`, `SQXTN`, `SQXTN2`, `SQXTUN`, `SQXTUN2`, `SUQADD`, `SXTL`, `SXTL2`, `UADDLP`, `UQXTN`, `UQXTN2`, `URECPE`, `URSQRTE`, `USQADD`, `UXTL`, `UXTL2`, `XTN`, `XTN2`.

### C3.6.17 SIMD by element arithmetic

###### Table C3-96 SIMD by element arithmetic instructions

$\triangle$ `FMLA`, `FMLAL`, `FMLAL2`, `FMLS`, `FMLSL`, `FMLSL2`, `FMUL`, `FMULX`, `MLA`, `MLS`, `MUL`, `SMLAL`, `SMLAL2`, `SMLSL`, `SMLSL2`, `SMULL`, `SMULL2`, `SQDMLAL`, `SQDMLAL2`, `SQDMLSL`, `SQDMLSL2`, `SQDMULL`, `SQDMULL2`, `SQRDMLAH`, `SQRDMLSH`, `SQRDMULH`, `UMLAL`, `UMLAL2`, `UMLSL`, `UMLSL2`, `UMULL`, `UMULL2`.

### C3.6.18 SIMD permute

###### Table C3-97 SIMD permute instructions

$\triangle$ `EXT`, `TRN1`, `TRN2`, `UZP1`, `UZP2`, `ZIP1`, `ZIP2`.

### C3.6.19 SIMD immediate

###### Table C3-98 SIMD immediate instructions

$\triangle$ `BIC`, `FMOV`, `MOVI`, `MVNI`, `ORR`.

### C3.6.20 SIMD shift (immediate)

###### Table C3-99 SIMD shift (immediate) instructions

$\triangle$ `RSHRN`, `RSHRN2`, `SHL`, `SHLL`, `SHLL2`, `SHRN`, `SHRN2`, `SLI`, `SQRSHRN`, `SQRSHRN2`, `SQRSHRUN`, `SQRSHRUN2`, `SQSHL`, `SQSHLU`, `SQSHRN`, `SQSHRN2`, `SQSHRUN`, `SQSHRUN2`, `SRI`, `SRSHR`, `SRSRA`, `SSHLL`, `SSHLL2`, `SSHR`, `SSRA`, `SXTL`, `SXTL2`, `UQRSHRN`, `UQRSHRN2`, `UQSHL`,`UQSHRN`, `UQSHRN2`, `URSHR`, `URSRA`, `USHLL`, `USHLL2`, `USHR`, `USRA`, `UXTL`, `UXTL2`.

### C3.6.21 SIMD floating-point and integer conversion

$\triangle$ The SIMD floating-point and integer conversion instructions generate the Invalid Operation floating-point exception in response to a floating-point input of NaN, infinity, or a numerical value that cannot be represented within the destination register. An out of range integer or a fixed-point result is saturated to the size of the destination register. A numeric result that differs from the input raises the Inexact floating-point exception.

###### Table C3-100 SIMD floating-point and integer conversion instructions

$\triangle$ `FCVTAS`, `FCVTAU`, `FCVTMS`, `FCVTMU`, `FCVTNS`, `FCVTNU`, `FCVTNS`, `FCVTNU`, `FCVTPS`, `FCVTPU`, `FCVTZS`, `FCVTZU`, `SCVTF`, `UCVTF`.

### C3.6.22 SIMD reduce (across vector lanes)

$\triangle$ The SIMD reduce (across vector lanes) instructions perform arithmetic operations horizontally, that is across all lanes of the input vector. They deliver a single scalar result.

###### Table C3-101 SIMD reduce (across vector lanes) instructions

$\triangle$ `ADDV`, `FMAXNMV`, `FMAXV`, `FMINNMV`, `FMINV`, `SADDLV`, `SMAXV`, `SMINV`, `UADDLV`, `UMAXV`, `UMINV`.

### C3.6.23 SIMD pairwise arithmetic

$\triangle$ The SIMD pairwise arithmetic instructions perform operations on pairs of adjacent elements and deliver a vector result.

###### Table C3-102 SIMD pairwise arithmetic instructions

$\triangle$ `ADDP`, `FADDP`, `FMAXNMP`, `FMAXP`, `FMINNMP`, `FMINP`, `SMAXP`, `SMINP`, `UMAXP`, `UMINP`.

### C3.6.24 SIMD integer dot product

$\triangle$ FEAT_DotProd provides SIMD instructions that perform the dot product of the four 8-bit subelements of the 32-bit elements of one vector with the four 8-bit subelements of a second vector. It provides two forms of the instructions, each with signed and unsigned versions:
- **Vector form**. The dot product is calculated for each element of the first vector with the corresponding element of the second vector.
- **Indexed form**. The dot product is calculated for each element of the first vector with the element of the second vector that is indicated by the index argument to the instruction.

$\triangle$ That is, a single element from the second vector is used, and the dot product is calcualted between each element fo the first vector and this single element from the second vector.

###### Table C3-103 SIMD integer dot product instructions

$\triangle$ `SDOT`, `UDOT`, `USDOT`, `SUDOT`.

### C3.6.25 SIMD table lookup

###### Table C3-104 SIMD table lookup instructions

$\triangle$ `TBL`, `TBX`.

### C3.6.26 SIMD complex number arithmetic

$\triangle$ FEAT_FCMA provides SIMD instructions that perform arithmetic on complex numbers held in element pairs in vector registers, where the less significant element of the pair contains the real component and the more significant element contains the imaginary component.

$\triangle$ These instructions provide double-precision and single-precision vectors. If FEAT_FP16 is implemented they are provide half-precision versions, otherwise the half-precision encodings are UNDEFINED.

###### Table C3-105 SIMD complex number arithmetic instructions

$\triangle$ `FCADD`, `FCMLA`.

### C3.6.27 SIMD BFloat16

$\triangle$ If FEAT_BF16 is implemented, the instructions in this section are available.

#### SIMD BFloat16 floating-point multiply-add

$\triangle$ The BFloat16 floating-point multiply-add instructions perform an implicit conversion of the bottom (even-numbered) or top (odd-numbered) BFloat16 source elements to IEEE754 single-precision floating-point format before performing a fused multiply-add without intermediate routing to the overlapping single-precision destination element. These instructions follow the normal floating-point behaviors that apply to single-precision arithmetic, controlled by the Effective value of the FPCR, and captured int he FPSR cumulative exception bits.

###### Table C3-106 SIMD BFloat16 floating-point multiply-add instructions

$\triangle$ `BFMLALB`, `BFMLALT`.




